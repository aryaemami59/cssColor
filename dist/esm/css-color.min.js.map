{
  "version": 3,
  "sources": ["../../node_modules/lru-cache/src/index.ts", "../../src/js/common.js", "../../src/js/color.js", "../../src/js/convert.js", "../../src/js/api.js"],
  "sourcesContent": ["/**\n * @module LRUCache\n */\n\n// module-private names and types\ntype Perf = { now: () => number }\nconst perf: Perf =\n  typeof performance === 'object' &&\n  performance &&\n  typeof performance.now === 'function'\n    ? performance\n    : Date\n\nconst warned = new Set<string>()\n\n// either a function or a class\ntype ForC = ((...a: any[]) => any) | { new (...a: any[]): any }\n\n/* c8 ignore start */\nconst PROCESS = (\n  typeof process === 'object' && !!process ? process : {}\n) as { [k: string]: any }\n/* c8 ignore start */\n\nconst emitWarning = (\n  msg: string,\n  type: string,\n  code: string,\n  fn: ForC\n) => {\n  typeof PROCESS.emitWarning === 'function'\n    ? PROCESS.emitWarning(msg, type, code, fn)\n    : console.error(`[${code}] ${type}: ${msg}`)\n}\n\nlet AC = globalThis.AbortController\nlet AS = globalThis.AbortSignal\n\n/* c8 ignore start */\nif (typeof AC === 'undefined') {\n  //@ts-ignore\n  AS = class AbortSignal {\n    onabort?: (...a: any[]) => any\n    _onabort: ((...a: any[]) => any)[] = []\n    reason?: any\n    aborted: boolean = false\n    addEventListener(_: string, fn: (...a: any[]) => any) {\n      this._onabort.push(fn)\n    }\n  }\n  //@ts-ignore\n  AC = class AbortController {\n    constructor() {\n      warnACPolyfill()\n    }\n    signal = new AS()\n    abort(reason: any) {\n      if (this.signal.aborted) return\n      //@ts-ignore\n      this.signal.reason = reason\n      //@ts-ignore\n      this.signal.aborted = true\n      //@ts-ignore\n      for (const fn of this.signal._onabort) {\n        fn(reason)\n      }\n      this.signal.onabort?.(reason)\n    }\n  }\n  let printACPolyfillWarning =\n    PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== '1'\n  const warnACPolyfill = () => {\n    if (!printACPolyfillWarning) return\n    printACPolyfillWarning = false\n    emitWarning(\n      'AbortController is not defined. If using lru-cache in ' +\n        'node 14, load an AbortController polyfill from the ' +\n        '`node-abort-controller` package. A minimal polyfill is ' +\n        'provided for use by LRUCache.fetch(), but it should not be ' +\n        'relied upon in other contexts (eg, passing it to other APIs that ' +\n        'use AbortController/AbortSignal might have undesirable effects). ' +\n        'You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.',\n      'NO_ABORT_CONTROLLER',\n      'ENOTSUP',\n      warnACPolyfill\n    )\n  }\n}\n/* c8 ignore stop */\n\nconst shouldWarn = (code: string) => !warned.has(code)\n\nconst TYPE = Symbol('type')\nexport type PosInt = number & { [TYPE]: 'Positive Integer' }\nexport type Index = number & { [TYPE]: 'LRUCache Index' }\n\nconst isPosInt = (n: any): n is PosInt =>\n  n && n === Math.floor(n) && n > 0 && isFinite(n)\n\nexport type UintArray = Uint8Array | Uint16Array | Uint32Array\nexport type NumberArray = UintArray | number[]\n\n/* c8 ignore start */\n// This is a little bit ridiculous, tbh.\n// The maximum array length is 2^32-1 or thereabouts on most JS impls.\n// And well before that point, you're caching the entire world, I mean,\n// that's ~32GB of just integers for the next/prev links, plus whatever\n// else to hold that many keys and values.  Just filling the memory with\n// zeroes at init time is brutal when you get that big.\n// But why not be complete?\n// Maybe in the future, these limits will have expanded.\nconst getUintArray = (max: number) =>\n  !isPosInt(max)\n    ? null\n    : max <= Math.pow(2, 8)\n    ? Uint8Array\n    : max <= Math.pow(2, 16)\n    ? Uint16Array\n    : max <= Math.pow(2, 32)\n    ? Uint32Array\n    : max <= Number.MAX_SAFE_INTEGER\n    ? ZeroArray\n    : null\n/* c8 ignore stop */\n\nclass ZeroArray extends Array<number> {\n  constructor(size: number) {\n    super(size)\n    this.fill(0)\n  }\n}\nexport type { ZeroArray }\nexport type { Stack }\n\nexport type StackLike = Stack | Index[]\nclass Stack {\n  heap: NumberArray\n  length: number\n  // private constructor\n  static #constructing: boolean = false\n  static create(max: number): StackLike {\n    const HeapCls = getUintArray(max)\n    if (!HeapCls) return []\n    Stack.#constructing = true\n    const s = new Stack(max, HeapCls)\n    Stack.#constructing = false\n    return s\n  }\n  constructor(\n    max: number,\n    HeapCls: { new (n: number): NumberArray }\n  ) {\n    /* c8 ignore start */\n    if (!Stack.#constructing) {\n      throw new TypeError('instantiate Stack using Stack.create(n)')\n    }\n    /* c8 ignore stop */\n    this.heap = new HeapCls(max)\n    this.length = 0\n  }\n  push(n: Index) {\n    this.heap[this.length++] = n\n  }\n  pop(): Index {\n    return this.heap[--this.length] as Index\n  }\n}\n\n/**\n * Promise representing an in-progress {@link LRUCache#fetch} call\n */\nexport type BackgroundFetch<V> = Promise<V | undefined> & {\n  __returned: BackgroundFetch<V> | undefined\n  __abortController: AbortController\n  __staleWhileFetching: V | undefined\n}\n\nexport type DisposeTask<K, V> = [\n  value: V,\n  key: K,\n  reason: LRUCache.DisposeReason\n]\n\nexport namespace LRUCache {\n  /**\n   * An integer greater than 0, reflecting the calculated size of items\n   */\n  export type Size = number\n\n  /**\n   * Integer greater than 0, representing some number of milliseconds, or the\n   * time at which a TTL started counting from.\n   */\n  export type Milliseconds = number\n\n  /**\n   * An integer greater than 0, reflecting a number of items\n   */\n  export type Count = number\n\n  /**\n   * The reason why an item was removed from the cache, passed\n   * to the {@link Disposer} methods.\n   *\n   * - `evict`: The item was evicted because it is the least recently used,\n   *   and the cache is full.\n   * - `set`: A new value was set, overwriting the old value being disposed.\n   * - `delete`: The item was explicitly deleted, either by calling\n   *   {@link LRUCache#delete}, {@link LRUCache#clear}, or\n   *   {@link LRUCache#set} with an undefined value.\n   * - `expire`: The item was removed due to exceeding its TTL.\n   * - `fetch`: A {@link OptionsBase#fetchMethod} operation returned\n   *   `undefined` or was aborted, causing the item to be deleted.\n   */\n  export type DisposeReason =\n    | 'evict'\n    | 'set'\n    | 'delete'\n    | 'expire'\n    | 'fetch'\n  /**\n   * A method called upon item removal, passed as the\n   * {@link OptionsBase.dispose} and/or\n   * {@link OptionsBase.disposeAfter} options.\n   */\n  export type Disposer<K, V> = (\n    value: V,\n    key: K,\n    reason: DisposeReason\n  ) => void\n\n  /**\n   * A function that returns the effective calculated size\n   * of an entry in the cache.\n   */\n  export type SizeCalculator<K, V> = (value: V, key: K) => Size\n\n  /**\n   * Options provided to the\n   * {@link OptionsBase.fetchMethod} function.\n   */\n  export interface FetcherOptions<K, V, FC = unknown> {\n    signal: AbortSignal\n    options: FetcherFetchOptions<K, V, FC>\n    /**\n     * Object provided in the {@link FetchOptions.context} option to\n     * {@link LRUCache#fetch}\n     */\n    context: FC\n  }\n\n  /**\n   * Occasionally, it may be useful to track the internal behavior of the\n   * cache, particularly for logging, debugging, or for behavior within the\n   * `fetchMethod`. To do this, you can pass a `status` object to the\n   * {@link LRUCache#fetch}, {@link LRUCache#get}, {@link LRUCache#set},\n   * {@link LRUCache#memo}, and {@link LRUCache#has} methods.\n   *\n   * The `status` option should be a plain JavaScript object. The following\n   * fields will be set on it appropriately, depending on the situation.\n   */\n  export interface Status<V> {\n    /**\n     * The status of a set() operation.\n     *\n     * - add: the item was not found in the cache, and was added\n     * - update: the item was in the cache, with the same value provided\n     * - replace: the item was in the cache, and replaced\n     * - miss: the item was not added to the cache for some reason\n     */\n    set?: 'add' | 'update' | 'replace' | 'miss'\n\n    /**\n     * the ttl stored for the item, or undefined if ttls are not used.\n     */\n    ttl?: Milliseconds\n\n    /**\n     * the start time for the item, or undefined if ttls are not used.\n     */\n    start?: Milliseconds\n\n    /**\n     * The timestamp used for TTL calculation\n     */\n    now?: Milliseconds\n\n    /**\n     * the remaining ttl for the item, or undefined if ttls are not used.\n     */\n    remainingTTL?: Milliseconds\n\n    /**\n     * The calculated size for the item, if sizes are used.\n     */\n    entrySize?: Size\n\n    /**\n     * The total calculated size of the cache, if sizes are used.\n     */\n    totalCalculatedSize?: Size\n\n    /**\n     * A flag indicating that the item was not stored, due to exceeding the\n     * {@link OptionsBase.maxEntrySize}\n     */\n    maxEntrySizeExceeded?: true\n\n    /**\n     * The old value, specified in the case of `set:'update'` or\n     * `set:'replace'`\n     */\n    oldValue?: V\n\n    /**\n     * The results of a {@link LRUCache#has} operation\n     *\n     * - hit: the item was found in the cache\n     * - stale: the item was found in the cache, but is stale\n     * - miss: the item was not found in the cache\n     */\n    has?: 'hit' | 'stale' | 'miss'\n\n    /**\n     * The status of a {@link LRUCache#fetch} operation.\n     * Note that this can change as the underlying fetch() moves through\n     * various states.\n     *\n     * - inflight: there is another fetch() for this key which is in process\n     * - get: there is no {@link OptionsBase.fetchMethod}, so\n     *   {@link LRUCache#get} was called.\n     * - miss: the item is not in cache, and will be fetched.\n     * - hit: the item is in the cache, and was resolved immediately.\n     * - stale: the item is in the cache, but stale.\n     * - refresh: the item is in the cache, and not stale, but\n     *   {@link FetchOptions.forceRefresh} was specified.\n     */\n    fetch?: 'get' | 'inflight' | 'miss' | 'hit' | 'stale' | 'refresh'\n\n    /**\n     * The {@link OptionsBase.fetchMethod} was called\n     */\n    fetchDispatched?: true\n\n    /**\n     * The cached value was updated after a successful call to\n     * {@link OptionsBase.fetchMethod}\n     */\n    fetchUpdated?: true\n\n    /**\n     * The reason for a fetch() rejection.  Either the error raised by the\n     * {@link OptionsBase.fetchMethod}, or the reason for an\n     * AbortSignal.\n     */\n    fetchError?: Error\n\n    /**\n     * The fetch received an abort signal\n     */\n    fetchAborted?: true\n\n    /**\n     * The abort signal received was ignored, and the fetch was allowed to\n     * continue.\n     */\n    fetchAbortIgnored?: true\n\n    /**\n     * The fetchMethod promise resolved successfully\n     */\n    fetchResolved?: true\n\n    /**\n     * The fetchMethod promise was rejected\n     */\n    fetchRejected?: true\n\n    /**\n     * The status of a {@link LRUCache#get} operation.\n     *\n     * - fetching: The item is currently being fetched.  If a previous value\n     *   is present and allowed, that will be returned.\n     * - stale: The item is in the cache, and is stale.\n     * - hit: the item is in the cache\n     * - miss: the item is not in the cache\n     */\n    get?: 'stale' | 'hit' | 'miss'\n\n    /**\n     * A fetch or get operation returned a stale value.\n     */\n    returnedStale?: true\n  }\n\n  /**\n   * options which override the options set in the LRUCache constructor\n   * when calling {@link LRUCache#fetch}.\n   *\n   * This is the union of {@link GetOptions} and {@link SetOptions}, plus\n   * {@link OptionsBase.noDeleteOnFetchRejection},\n   * {@link OptionsBase.allowStaleOnFetchRejection},\n   * {@link FetchOptions.forceRefresh}, and\n   * {@link FetcherOptions.context}\n   *\n   * Any of these may be modified in the {@link OptionsBase.fetchMethod}\n   * function, but the {@link GetOptions} fields will of course have no\n   * effect, as the {@link LRUCache#get} call already happened by the time\n   * the fetchMethod is called.\n   */\n  export interface FetcherFetchOptions<K, V, FC = unknown>\n    extends Pick<\n      OptionsBase<K, V, FC>,\n      | 'allowStale'\n      | 'updateAgeOnGet'\n      | 'noDeleteOnStaleGet'\n      | 'sizeCalculation'\n      | 'ttl'\n      | 'noDisposeOnSet'\n      | 'noUpdateTTL'\n      | 'noDeleteOnFetchRejection'\n      | 'allowStaleOnFetchRejection'\n      | 'ignoreFetchAbort'\n      | 'allowStaleOnFetchAbort'\n    > {\n    status?: Status<V>\n    size?: Size\n  }\n\n  /**\n   * Options that may be passed to the {@link LRUCache#fetch} method.\n   */\n  export interface FetchOptions<K, V, FC>\n    extends FetcherFetchOptions<K, V, FC> {\n    /**\n     * Set to true to force a re-load of the existing data, even if it\n     * is not yet stale.\n     */\n    forceRefresh?: boolean\n    /**\n     * Context provided to the {@link OptionsBase.fetchMethod} as\n     * the {@link FetcherOptions.context} param.\n     *\n     * If the FC type is specified as unknown (the default),\n     * undefined or void, then this is optional.  Otherwise, it will\n     * be required.\n     */\n    context?: FC\n    signal?: AbortSignal\n    status?: Status<V>\n  }\n  /**\n   * Options provided to {@link LRUCache#fetch} when the FC type is something\n   * other than `unknown`, `undefined`, or `void`\n   */\n  export interface FetchOptionsWithContext<K, V, FC>\n    extends FetchOptions<K, V, FC> {\n    context: FC\n  }\n  /**\n   * Options provided to {@link LRUCache#fetch} when the FC type is\n   * `undefined` or `void`\n   */\n  export interface FetchOptionsNoContext<K, V>\n    extends FetchOptions<K, V, undefined> {\n    context?: undefined\n  }\n\n  export interface MemoOptions<K, V, FC = unknown>\n    extends Pick<\n      OptionsBase<K, V, FC>,\n      | 'allowStale'\n      | 'updateAgeOnGet'\n      | 'noDeleteOnStaleGet'\n      | 'sizeCalculation'\n      | 'ttl'\n      | 'noDisposeOnSet'\n      | 'noUpdateTTL'\n      | 'noDeleteOnFetchRejection'\n      | 'allowStaleOnFetchRejection'\n      | 'ignoreFetchAbort'\n      | 'allowStaleOnFetchAbort'\n    > {\n    /**\n     * Set to true to force a re-load of the existing data, even if it\n     * is not yet stale.\n     */\n    forceRefresh?: boolean\n    /**\n     * Context provided to the {@link OptionsBase.memoMethod} as\n     * the {@link MemoizerOptions.context} param.\n     *\n     * If the FC type is specified as unknown (the default),\n     * undefined or void, then this is optional.  Otherwise, it will\n     * be required.\n     */\n    context?: FC\n    status?: Status<V>\n  }\n  /**\n   * Options provided to {@link LRUCache#memo} when the FC type is something\n   * other than `unknown`, `undefined`, or `void`\n   */\n  export interface MemoOptionsWithContext<K, V, FC>\n    extends MemoOptions<K, V, FC> {\n    context: FC\n  }\n  /**\n   * Options provided to {@link LRUCache#memo} when the FC type is\n   * `undefined` or `void`\n   */\n  export interface MemoOptionsNoContext<K, V>\n    extends MemoOptions<K, V, undefined> {\n    context?: undefined\n  }\n\n  /**\n   * Options provided to the\n   * {@link OptionsBase.memoMethod} function.\n   */\n  export interface MemoizerOptions<K, V, FC = unknown> {\n    options: MemoizerMemoOptions<K, V, FC>\n    /**\n     * Object provided in the {@link MemoOptions.context} option to\n     * {@link LRUCache#memo}\n     */\n    context: FC\n  }\n\n  /**\n   * options which override the options set in the LRUCache constructor\n   * when calling {@link LRUCache#memo}.\n   *\n   * This is the union of {@link GetOptions} and {@link SetOptions}, plus\n   * {@link MemoOptions.forceRefresh}, and\n   * {@link MemoOptions.context}\n   *\n   * Any of these may be modified in the {@link OptionsBase.memoMethod}\n   * function, but the {@link GetOptions} fields will of course have no\n   * effect, as the {@link LRUCache#get} call already happened by the time\n   * the memoMethod is called.\n   */\n  export interface MemoizerMemoOptions<K, V, FC = unknown>\n    extends Pick<\n      OptionsBase<K, V, FC>,\n      | 'allowStale'\n      | 'updateAgeOnGet'\n      | 'noDeleteOnStaleGet'\n      | 'sizeCalculation'\n      | 'ttl'\n      | 'noDisposeOnSet'\n      | 'noUpdateTTL'\n    > {\n    status?: Status<V>\n    size?: Size\n    start?: Milliseconds\n  }\n\n  /**\n   * Options that may be passed to the {@link LRUCache#has} method.\n   */\n  export interface HasOptions<K, V, FC>\n    extends Pick<OptionsBase<K, V, FC>, 'updateAgeOnHas'> {\n    status?: Status<V>\n  }\n\n  /**\n   * Options that may be passed to the {@link LRUCache#get} method.\n   */\n  export interface GetOptions<K, V, FC>\n    extends Pick<\n      OptionsBase<K, V, FC>,\n      'allowStale' | 'updateAgeOnGet' | 'noDeleteOnStaleGet'\n    > {\n    status?: Status<V>\n  }\n\n  /**\n   * Options that may be passed to the {@link LRUCache#peek} method.\n   */\n  export interface PeekOptions<K, V, FC>\n    extends Pick<OptionsBase<K, V, FC>, 'allowStale'> {}\n\n  /**\n   * Options that may be passed to the {@link LRUCache#set} method.\n   */\n  export interface SetOptions<K, V, FC>\n    extends Pick<\n      OptionsBase<K, V, FC>,\n      'sizeCalculation' | 'ttl' | 'noDisposeOnSet' | 'noUpdateTTL'\n    > {\n    /**\n     * If size tracking is enabled, then setting an explicit size\n     * in the {@link LRUCache#set} call will prevent calling the\n     * {@link OptionsBase.sizeCalculation} function.\n     */\n    size?: Size\n    /**\n     * If TTL tracking is enabled, then setting an explicit start\n     * time in the {@link LRUCache#set} call will override the\n     * default time from `performance.now()` or `Date.now()`.\n     *\n     * Note that it must be a valid value for whichever time-tracking\n     * method is in use.\n     */\n    start?: Milliseconds\n    status?: Status<V>\n  }\n\n  /**\n   * The type signature for the {@link OptionsBase.fetchMethod} option.\n   */\n  export type Fetcher<K, V, FC = unknown> = (\n    key: K,\n    staleValue: V | undefined,\n    options: FetcherOptions<K, V, FC>\n  ) => Promise<V | undefined | void> | V | undefined | void\n\n  /**\n   * the type signature for the {@link OptionsBase.memoMethod} option.\n   */\n  export type Memoizer<K, V, FC = unknown> = (\n    key: K,\n    staleValue: V | undefined,\n    options: MemoizerOptions<K, V, FC>\n  ) => V\n\n  /**\n   * Options which may be passed to the {@link LRUCache} constructor.\n   *\n   * Most of these may be overridden in the various options that use\n   * them.\n   *\n   * Despite all being technically optional, the constructor requires that\n   * a cache is at minimum limited by one or more of {@link OptionsBase.max},\n   * {@link OptionsBase.ttl}, or {@link OptionsBase.maxSize}.\n   *\n   * If {@link OptionsBase.ttl} is used alone, then it is strongly advised\n   * (and in fact required by the type definitions here) that the cache\n   * also set {@link OptionsBase.ttlAutopurge}, to prevent potentially\n   * unbounded storage.\n   *\n   * All options are also available on the {@link LRUCache} instance, making\n   * it safe to pass an LRUCache instance as the options argumemnt to\n   * make another empty cache of the same type.\n   *\n   * Some options are marked as read-only, because changing them after\n   * instantiation is not safe. Changing any of the other options will of\n   * course only have an effect on subsequent method calls.\n   */\n  export interface OptionsBase<K, V, FC> {\n    /**\n     * The maximum number of items to store in the cache before evicting\n     * old entries. This is read-only on the {@link LRUCache} instance,\n     * and may not be overridden.\n     *\n     * If set, then storage space will be pre-allocated at construction\n     * time, and the cache will perform significantly faster.\n     *\n     * Note that significantly fewer items may be stored, if\n     * {@link OptionsBase.maxSize} and/or {@link OptionsBase.ttl} are also\n     * set.\n     *\n     * **It is strongly recommended to set a `max` to prevent unbounded growth\n     * of the cache.**\n     */\n    max?: Count\n\n    /**\n     * Max time in milliseconds for items to live in cache before they are\n     * considered stale.  Note that stale items are NOT preemptively removed by\n     * default, and MAY live in the cache, contributing to its LRU max, long\n     * after they have expired, unless {@link OptionsBase.ttlAutopurge} is\n     * set.\n     *\n     * If set to `0` (the default value), then that means \"do not track\n     * TTL\", not \"expire immediately\".\n     *\n     * Also, as this cache is optimized for LRU/MRU operations, some of\n     * the staleness/TTL checks will reduce performance, as they will incur\n     * overhead by deleting items.\n     *\n     * This is not primarily a TTL cache, and does not make strong TTL\n     * guarantees. There is no pre-emptive pruning of expired items, but you\n     * _may_ set a TTL on the cache, and it will treat expired items as missing\n     * when they are fetched, and delete them.\n     *\n     * Optional, but must be a non-negative integer in ms if specified.\n     *\n     * This may be overridden by passing an options object to `cache.set()`.\n     *\n     * At least one of `max`, `maxSize`, or `TTL` is required. This must be a\n     * positive integer if set.\n     *\n     * Even if ttl tracking is enabled, **it is strongly recommended to set a\n     * `max` to prevent unbounded growth of the cache.**\n     *\n     * If ttl tracking is enabled, and `max` and `maxSize` are not set,\n     * and `ttlAutopurge` is not set, then a warning will be emitted\n     * cautioning about the potential for unbounded memory consumption.\n     * (The TypeScript definitions will also discourage this.)\n     */\n    ttl?: Milliseconds\n\n    /**\n     * Minimum amount of time in ms in which to check for staleness.\n     * Defaults to 1, which means that the current time is checked\n     * at most once per millisecond.\n     *\n     * Set to 0 to check the current time every time staleness is tested.\n     * (This reduces performance, and is theoretically unnecessary.)\n     *\n     * Setting this to a higher value will improve performance somewhat\n     * while using ttl tracking, albeit at the expense of keeping stale\n     * items around a bit longer than their TTLs would indicate.\n     *\n     * @default 1\n     */\n    ttlResolution?: Milliseconds\n\n    /**\n     * Preemptively remove stale items from the cache.\n     *\n     * Note that this may *significantly* degrade performance, especially if\n     * the cache is storing a large number of items. It is almost always best\n     * to just leave the stale items in the cache, and let them fall out as new\n     * items are added.\n     *\n     * Note that this means that {@link OptionsBase.allowStale} is a bit\n     * pointless, as stale items will be deleted almost as soon as they\n     * expire.\n     *\n     * Use with caution!\n     */\n    ttlAutopurge?: boolean\n\n    /**\n     * When using time-expiring entries with `ttl`, setting this to `true` will\n     * make each item's age reset to 0 whenever it is retrieved from cache with\n     * {@link LRUCache#get}, causing it to not expire. (It can still fall out\n     * of cache based on recency of use, of course.)\n     *\n     * Has no effect if {@link OptionsBase.ttl} is not set.\n     *\n     * This may be overridden by passing an options object to `cache.get()`.\n     */\n    updateAgeOnGet?: boolean\n\n    /**\n     * When using time-expiring entries with `ttl`, setting this to `true` will\n     * make each item's age reset to 0 whenever its presence in the cache is\n     * checked with {@link LRUCache#has}, causing it to not expire. (It can\n     * still fall out of cache based on recency of use, of course.)\n     *\n     * Has no effect if {@link OptionsBase.ttl} is not set.\n     */\n    updateAgeOnHas?: boolean\n\n    /**\n     * Allow {@link LRUCache#get} and {@link LRUCache#fetch} calls to return\n     * stale data, if available.\n     *\n     * By default, if you set `ttl`, stale items will only be deleted from the\n     * cache when you `get(key)`. That is, it's not preemptively pruning items,\n     * unless {@link OptionsBase.ttlAutopurge} is set.\n     *\n     * If you set `allowStale:true`, it'll return the stale value *as well as*\n     * deleting it. If you don't set this, then it'll return `undefined` when\n     * you try to get a stale entry.\n     *\n     * Note that when a stale entry is fetched, _even if it is returned due to\n     * `allowStale` being set_, it is removed from the cache immediately. You\n     * can suppress this behavior by setting\n     * {@link OptionsBase.noDeleteOnStaleGet}, either in the constructor, or in\n     * the options provided to {@link LRUCache#get}.\n     *\n     * This may be overridden by passing an options object to `cache.get()`.\n     * The `cache.has()` method will always return `false` for stale items.\n     *\n     * Only relevant if a ttl is set.\n     */\n    allowStale?: boolean\n\n    /**\n     * Function that is called on items when they are dropped from the\n     * cache, as `dispose(value, key, reason)`.\n     *\n     * This can be handy if you want to close file descriptors or do\n     * other cleanup tasks when items are no longer stored in the cache.\n     *\n     * **NOTE**: It is called _before_ the item has been fully removed\n     * from the cache, so if you want to put it right back in, you need\n     * to wait until the next tick. If you try to add it back in during\n     * the `dispose()` function call, it will break things in subtle and\n     * weird ways.\n     *\n     * Unlike several other options, this may _not_ be overridden by\n     * passing an option to `set()`, for performance reasons.\n     *\n     * The `reason` will be one of the following strings, corresponding\n     * to the reason for the item's deletion:\n     *\n     * - `evict` Item was evicted to make space for a new addition\n     * - `set` Item was overwritten by a new value\n     * - `expire` Item expired its TTL\n     * - `fetch` Item was deleted due to a failed or aborted fetch, or a\n     *   fetchMethod returning `undefined.\n     * - `delete` Item was removed by explicit `cache.delete(key)`,\n     *   `cache.clear()`, or `cache.set(key, undefined)`.\n     */\n    dispose?: Disposer<K, V>\n\n    /**\n     * The same as {@link OptionsBase.dispose}, but called *after* the entry\n     * is completely removed and the cache is once again in a clean state.\n     *\n     * It is safe to add an item right back into the cache at this point.\n     * However, note that it is *very* easy to inadvertently create infinite\n     * recursion this way.\n     */\n    disposeAfter?: Disposer<K, V>\n\n    /**\n     * Set to true to suppress calling the\n     * {@link OptionsBase.dispose} function if the entry key is\n     * still accessible within the cache.\n     *\n     * This may be overridden by passing an options object to\n     * {@link LRUCache#set}.\n     *\n     * Only relevant if `dispose` or `disposeAfter` are set.\n     */\n    noDisposeOnSet?: boolean\n\n    /**\n     * Boolean flag to tell the cache to not update the TTL when setting a new\n     * value for an existing key (ie, when updating a value rather than\n     * inserting a new value).  Note that the TTL value is _always_ set (if\n     * provided) when adding a new entry into the cache.\n     *\n     * Has no effect if a {@link OptionsBase.ttl} is not set.\n     *\n     * May be passed as an option to {@link LRUCache#set}.\n     */\n    noUpdateTTL?: boolean\n\n    /**\n     * Set to a positive integer to track the sizes of items added to the\n     * cache, and automatically evict items in order to stay below this size.\n     * Note that this may result in fewer than `max` items being stored.\n     *\n     * Attempting to add an item to the cache whose calculated size is greater\n     * that this amount will be a no-op. The item will not be cached, and no\n     * other items will be evicted.\n     *\n     * Optional, must be a positive integer if provided.\n     *\n     * Sets `maxEntrySize` to the same value, unless a different value is\n     * provided for `maxEntrySize`.\n     *\n     * At least one of `max`, `maxSize`, or `TTL` is required. This must be a\n     * positive integer if set.\n     *\n     * Even if size tracking is enabled, **it is strongly recommended to set a\n     * `max` to prevent unbounded growth of the cache.**\n     *\n     * Note also that size tracking can negatively impact performance,\n     * though for most cases, only minimally.\n     */\n    maxSize?: Size\n\n    /**\n     * The maximum allowed size for any single item in the cache.\n     *\n     * If a larger item is passed to {@link LRUCache#set} or returned by a\n     * {@link OptionsBase.fetchMethod} or {@link OptionsBase.memoMethod}, then\n     * it will not be stored in the cache.\n     *\n     * Attempting to add an item whose calculated size is greater than\n     * this amount will not cache the item or evict any old items, but\n     * WILL delete an existing value if one is already present.\n     *\n     * Optional, must be a positive integer if provided. Defaults to\n     * the value of `maxSize` if provided.\n     */\n    maxEntrySize?: Size\n\n    /**\n     * A function that returns a number indicating the item's size.\n     *\n     * Requires {@link OptionsBase.maxSize} to be set.\n     *\n     * If not provided, and {@link OptionsBase.maxSize} or\n     * {@link OptionsBase.maxEntrySize} are set, then all\n     * {@link LRUCache#set} calls **must** provide an explicit\n     * {@link SetOptions.size} or sizeCalculation param.\n     */\n    sizeCalculation?: SizeCalculator<K, V>\n\n    /**\n     * Method that provides the implementation for {@link LRUCache#fetch}\n     *\n     * ```ts\n     * fetchMethod(key, staleValue, { signal, options, context })\n     * ```\n     *\n     * If `fetchMethod` is not provided, then `cache.fetch(key)` is equivalent\n     * to `Promise.resolve(cache.get(key))`.\n     *\n     * If at any time, `signal.aborted` is set to `true`, or if the\n     * `signal.onabort` method is called, or if it emits an `'abort'` event\n     * which you can listen to with `addEventListener`, then that means that\n     * the fetch should be abandoned. This may be passed along to async\n     * functions aware of AbortController/AbortSignal behavior.\n     *\n     * The `fetchMethod` should **only** return `undefined` or a Promise\n     * resolving to `undefined` if the AbortController signaled an `abort`\n     * event. In all other cases, it should return or resolve to a value\n     * suitable for adding to the cache.\n     *\n     * The `options` object is a union of the options that may be provided to\n     * `set()` and `get()`. If they are modified, then that will result in\n     * modifying the settings to `cache.set()` when the value is resolved, and\n     * in the case of\n     * {@link OptionsBase.noDeleteOnFetchRejection} and\n     * {@link OptionsBase.allowStaleOnFetchRejection}, the handling of\n     * `fetchMethod` failures.\n     *\n     * For example, a DNS cache may update the TTL based on the value returned\n     * from a remote DNS server by changing `options.ttl` in the `fetchMethod`.\n     */\n    fetchMethod?: Fetcher<K, V, FC>\n\n    /**\n     * Method that provides the implementation for {@link LRUCache#memo}\n     */\n    memoMethod?: Memoizer<K, V, FC>\n\n    /**\n     * Set to true to suppress the deletion of stale data when a\n     * {@link OptionsBase.fetchMethod} returns a rejected promise.\n     */\n    noDeleteOnFetchRejection?: boolean\n\n    /**\n     * Do not delete stale items when they are retrieved with\n     * {@link LRUCache#get}.\n     *\n     * Note that the `get` return value will still be `undefined`\n     * unless {@link OptionsBase.allowStale} is true.\n     *\n     * When using time-expiring entries with `ttl`, by default stale\n     * items will be removed from the cache when the key is accessed\n     * with `cache.get()`.\n     *\n     * Setting this option will cause stale items to remain in the cache, until\n     * they are explicitly deleted with `cache.delete(key)`, or retrieved with\n     * `noDeleteOnStaleGet` set to `false`.\n     *\n     * This may be overridden by passing an options object to `cache.get()`.\n     *\n     * Only relevant if a ttl is used.\n     */\n    noDeleteOnStaleGet?: boolean\n\n    /**\n     * Set to true to allow returning stale data when a\n     * {@link OptionsBase.fetchMethod} throws an error or returns a rejected\n     * promise.\n     *\n     * This differs from using {@link OptionsBase.allowStale} in that stale\n     * data will ONLY be returned in the case that the {@link LRUCache#fetch}\n     * fails, not any other times.\n     *\n     * If a `fetchMethod` fails, and there is no stale value available, the\n     * `fetch()` will resolve to `undefined`. Ie, all `fetchMethod` errors are\n     * suppressed.\n     *\n     * Implies `noDeleteOnFetchRejection`.\n     *\n     * This may be set in calls to `fetch()`, or defaulted on the constructor,\n     * or overridden by modifying the options object in the `fetchMethod`.\n     */\n    allowStaleOnFetchRejection?: boolean\n\n    /**\n     * Set to true to return a stale value from the cache when the\n     * `AbortSignal` passed to the {@link OptionsBase.fetchMethod} dispatches\n     * an `'abort'` event, whether user-triggered, or due to internal cache\n     * behavior.\n     *\n     * Unless {@link OptionsBase.ignoreFetchAbort} is also set, the underlying\n     * {@link OptionsBase.fetchMethod} will still be considered canceled, and\n     * any value it returns will be ignored and not cached.\n     *\n     * Caveat: since fetches are aborted when a new value is explicitly\n     * set in the cache, this can lead to fetch returning a stale value,\n     * since that was the fallback value _at the moment the `fetch()` was\n     * initiated_, even though the new updated value is now present in\n     * the cache.\n     *\n     * For example:\n     *\n     * ```ts\n     * const cache = new LRUCache<string, any>({\n     *   ttl: 100,\n     *   fetchMethod: async (url, oldValue, { signal }) =>  {\n     *     const res = await fetch(url, { signal })\n     *     return await res.json()\n     *   }\n     * })\n     * cache.set('https://example.com/', { some: 'data' })\n     * // 100ms go by...\n     * const result = cache.fetch('https://example.com/')\n     * cache.set('https://example.com/', { other: 'thing' })\n     * console.log(await result) // { some: 'data' }\n     * console.log(cache.get('https://example.com/')) // { other: 'thing' }\n     * ```\n     */\n    allowStaleOnFetchAbort?: boolean\n\n    /**\n     * Set to true to ignore the `abort` event emitted by the `AbortSignal`\n     * object passed to {@link OptionsBase.fetchMethod}, and still cache the\n     * resulting resolution value, as long as it is not `undefined`.\n     *\n     * When used on its own, this means aborted {@link LRUCache#fetch} calls\n     * are not immediately resolved or rejected when they are aborted, and\n     * instead take the full time to await.\n     *\n     * When used with {@link OptionsBase.allowStaleOnFetchAbort}, aborted\n     * {@link LRUCache#fetch} calls will resolve immediately to their stale\n     * cached value or `undefined`, and will continue to process and eventually\n     * update the cache when they resolve, as long as the resulting value is\n     * not `undefined`, thus supporting a \"return stale on timeout while\n     * refreshing\" mechanism by passing `AbortSignal.timeout(n)` as the signal.\n     *\n     * For example:\n     *\n     * ```ts\n     * const c = new LRUCache({\n     *   ttl: 100,\n     *   ignoreFetchAbort: true,\n     *   allowStaleOnFetchAbort: true,\n     *   fetchMethod: async (key, oldValue, { signal }) => {\n     *     // note: do NOT pass the signal to fetch()!\n     *     // let's say this fetch can take a long time.\n     *     const res = await fetch(`https://slow-backend-server/${key}`)\n     *     return await res.json()\n     *   },\n     * })\n     *\n     * // this will return the stale value after 100ms, while still\n     * // updating in the background for next time.\n     * const val = await c.fetch('key', { signal: AbortSignal.timeout(100) })\n     * ```\n     *\n     * **Note**: regardless of this setting, an `abort` event _is still\n     * emitted on the `AbortSignal` object_, so may result in invalid results\n     * when passed to other underlying APIs that use AbortSignals.\n     *\n     * This may be overridden in the {@link OptionsBase.fetchMethod} or the\n     * call to {@link LRUCache#fetch}.\n     */\n    ignoreFetchAbort?: boolean\n  }\n\n  export interface OptionsMaxLimit<K, V, FC>\n    extends OptionsBase<K, V, FC> {\n    max: Count\n  }\n  export interface OptionsTTLLimit<K, V, FC>\n    extends OptionsBase<K, V, FC> {\n    ttl: Milliseconds\n    ttlAutopurge: boolean\n  }\n  export interface OptionsSizeLimit<K, V, FC>\n    extends OptionsBase<K, V, FC> {\n    maxSize: Size\n  }\n\n  /**\n   * The valid safe options for the {@link LRUCache} constructor\n   */\n  export type Options<K, V, FC> =\n    | OptionsMaxLimit<K, V, FC>\n    | OptionsSizeLimit<K, V, FC>\n    | OptionsTTLLimit<K, V, FC>\n\n  /**\n   * Entry objects used by {@link LRUCache#load} and {@link LRUCache#dump},\n   * and returned by {@link LRUCache#info}.\n   */\n  export interface Entry<V> {\n    value: V\n    ttl?: Milliseconds\n    size?: Size\n    start?: Milliseconds\n  }\n}\n\n/**\n * Default export, the thing you're using this module to get.\n *\n * The `K` and `V` types define the key and value types, respectively. The\n * optional `FC` type defines the type of the `context` object passed to\n * `cache.fetch()` and `cache.memo()`.\n *\n * Keys and values **must not** be `null` or `undefined`.\n *\n * All properties from the options object (with the exception of `max`,\n * `maxSize`, `fetchMethod`, `memoMethod`, `dispose` and `disposeAfter`) are\n * added as normal public members. (The listed options are read-only getters.)\n *\n * Changing any of these will alter the defaults for subsequent method calls.\n */\nexport class LRUCache<K extends {}, V extends {}, FC = unknown> {\n  // options that cannot be changed without disaster\n  readonly #max: LRUCache.Count\n  readonly #maxSize: LRUCache.Size\n  readonly #dispose?: LRUCache.Disposer<K, V>\n  readonly #disposeAfter?: LRUCache.Disposer<K, V>\n  readonly #fetchMethod?: LRUCache.Fetcher<K, V, FC>\n  readonly #memoMethod?: LRUCache.Memoizer<K, V, FC>\n\n  /**\n   * {@link LRUCache.OptionsBase.ttl}\n   */\n  ttl: LRUCache.Milliseconds\n\n  /**\n   * {@link LRUCache.OptionsBase.ttlResolution}\n   */\n  ttlResolution: LRUCache.Milliseconds\n  /**\n   * {@link LRUCache.OptionsBase.ttlAutopurge}\n   */\n  ttlAutopurge: boolean\n  /**\n   * {@link LRUCache.OptionsBase.updateAgeOnGet}\n   */\n  updateAgeOnGet: boolean\n  /**\n   * {@link LRUCache.OptionsBase.updateAgeOnHas}\n   */\n  updateAgeOnHas: boolean\n  /**\n   * {@link LRUCache.OptionsBase.allowStale}\n   */\n  allowStale: boolean\n\n  /**\n   * {@link LRUCache.OptionsBase.noDisposeOnSet}\n   */\n  noDisposeOnSet: boolean\n  /**\n   * {@link LRUCache.OptionsBase.noUpdateTTL}\n   */\n  noUpdateTTL: boolean\n  /**\n   * {@link LRUCache.OptionsBase.maxEntrySize}\n   */\n  maxEntrySize: LRUCache.Size\n  /**\n   * {@link LRUCache.OptionsBase.sizeCalculation}\n   */\n  sizeCalculation?: LRUCache.SizeCalculator<K, V>\n  /**\n   * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}\n   */\n  noDeleteOnFetchRejection: boolean\n  /**\n   * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}\n   */\n  noDeleteOnStaleGet: boolean\n  /**\n   * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}\n   */\n  allowStaleOnFetchAbort: boolean\n  /**\n   * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}\n   */\n  allowStaleOnFetchRejection: boolean\n  /**\n   * {@link LRUCache.OptionsBase.ignoreFetchAbort}\n   */\n  ignoreFetchAbort: boolean\n\n  // computed properties\n  #size: LRUCache.Count\n  #calculatedSize: LRUCache.Size\n  #keyMap: Map<K, Index>\n  #keyList: (K | undefined)[]\n  #valList: (V | BackgroundFetch<V> | undefined)[]\n  #next: NumberArray\n  #prev: NumberArray\n  #head: Index\n  #tail: Index\n  #free: StackLike\n  #disposed?: DisposeTask<K, V>[]\n  #sizes?: ZeroArray\n  #starts?: ZeroArray\n  #ttls?: ZeroArray\n\n  #hasDispose: boolean\n  #hasFetchMethod: boolean\n  #hasDisposeAfter: boolean\n\n  /**\n   * Do not call this method unless you need to inspect the\n   * inner workings of the cache.  If anything returned by this\n   * object is modified in any way, strange breakage may occur.\n   *\n   * These fields are private for a reason!\n   *\n   * @internal\n   */\n  static unsafeExposeInternals<\n    K extends {},\n    V extends {},\n    FC extends unknown = unknown\n  >(c: LRUCache<K, V, FC>) {\n    return {\n      // properties\n      starts: c.#starts,\n      ttls: c.#ttls,\n      sizes: c.#sizes,\n      keyMap: c.#keyMap as Map<K, number>,\n      keyList: c.#keyList,\n      valList: c.#valList,\n      next: c.#next,\n      prev: c.#prev,\n      get head() {\n        return c.#head\n      },\n      get tail() {\n        return c.#tail\n      },\n      free: c.#free,\n      // methods\n      isBackgroundFetch: (p: any) => c.#isBackgroundFetch(p),\n      backgroundFetch: (\n        k: K,\n        index: number | undefined,\n        options: LRUCache.FetchOptions<K, V, FC>,\n        context: any\n      ): BackgroundFetch<V> =>\n        c.#backgroundFetch(\n          k,\n          index as Index | undefined,\n          options,\n          context\n        ),\n      moveToTail: (index: number): void =>\n        c.#moveToTail(index as Index),\n      indexes: (options?: { allowStale: boolean }) =>\n        c.#indexes(options),\n      rindexes: (options?: { allowStale: boolean }) =>\n        c.#rindexes(options),\n      isStale: (index: number | undefined) =>\n        c.#isStale(index as Index),\n    }\n  }\n\n  // Protected read-only members\n\n  /**\n   * {@link LRUCache.OptionsBase.max} (read-only)\n   */\n  get max(): LRUCache.Count {\n    return this.#max\n  }\n  /**\n   * {@link LRUCache.OptionsBase.maxSize} (read-only)\n   */\n  get maxSize(): LRUCache.Count {\n    return this.#maxSize\n  }\n  /**\n   * The total computed size of items in the cache (read-only)\n   */\n  get calculatedSize(): LRUCache.Size {\n    return this.#calculatedSize\n  }\n  /**\n   * The number of items stored in the cache (read-only)\n   */\n  get size(): LRUCache.Count {\n    return this.#size\n  }\n  /**\n   * {@link LRUCache.OptionsBase.fetchMethod} (read-only)\n   */\n  get fetchMethod(): LRUCache.Fetcher<K, V, FC> | undefined {\n    return this.#fetchMethod\n  }\n  get memoMethod(): LRUCache.Memoizer<K, V, FC> | undefined {\n    return this.#memoMethod\n  }\n  /**\n   * {@link LRUCache.OptionsBase.dispose} (read-only)\n   */\n  get dispose() {\n    return this.#dispose\n  }\n  /**\n   * {@link LRUCache.OptionsBase.disposeAfter} (read-only)\n   */\n  get disposeAfter() {\n    return this.#disposeAfter\n  }\n\n  constructor(\n    options: LRUCache.Options<K, V, FC> | LRUCache<K, V, FC>\n  ) {\n    const {\n      max = 0,\n      ttl,\n      ttlResolution = 1,\n      ttlAutopurge,\n      updateAgeOnGet,\n      updateAgeOnHas,\n      allowStale,\n      dispose,\n      disposeAfter,\n      noDisposeOnSet,\n      noUpdateTTL,\n      maxSize = 0,\n      maxEntrySize = 0,\n      sizeCalculation,\n      fetchMethod,\n      memoMethod,\n      noDeleteOnFetchRejection,\n      noDeleteOnStaleGet,\n      allowStaleOnFetchRejection,\n      allowStaleOnFetchAbort,\n      ignoreFetchAbort,\n    } = options\n\n    if (max !== 0 && !isPosInt(max)) {\n      throw new TypeError('max option must be a nonnegative integer')\n    }\n\n    const UintArray = max ? getUintArray(max) : Array\n    if (!UintArray) {\n      throw new Error('invalid max value: ' + max)\n    }\n\n    this.#max = max\n    this.#maxSize = maxSize\n    this.maxEntrySize = maxEntrySize || this.#maxSize\n    this.sizeCalculation = sizeCalculation\n    if (this.sizeCalculation) {\n      if (!this.#maxSize && !this.maxEntrySize) {\n        throw new TypeError(\n          'cannot set sizeCalculation without setting maxSize or maxEntrySize'\n        )\n      }\n      if (typeof this.sizeCalculation !== 'function') {\n        throw new TypeError('sizeCalculation set to non-function')\n      }\n    }\n\n    if (\n      memoMethod !== undefined &&\n      typeof memoMethod !== 'function'\n    ) {\n      throw new TypeError('memoMethod must be a function if defined')\n    }\n    this.#memoMethod = memoMethod\n\n    if (\n      fetchMethod !== undefined &&\n      typeof fetchMethod !== 'function'\n    ) {\n      throw new TypeError(\n        'fetchMethod must be a function if specified'\n      )\n    }\n    this.#fetchMethod = fetchMethod\n    this.#hasFetchMethod = !!fetchMethod\n\n    this.#keyMap = new Map()\n    this.#keyList = new Array(max).fill(undefined)\n    this.#valList = new Array(max).fill(undefined)\n    this.#next = new UintArray(max)\n    this.#prev = new UintArray(max)\n    this.#head = 0 as Index\n    this.#tail = 0 as Index\n    this.#free = Stack.create(max)\n    this.#size = 0\n    this.#calculatedSize = 0\n\n    if (typeof dispose === 'function') {\n      this.#dispose = dispose\n    }\n    if (typeof disposeAfter === 'function') {\n      this.#disposeAfter = disposeAfter\n      this.#disposed = []\n    } else {\n      this.#disposeAfter = undefined\n      this.#disposed = undefined\n    }\n    this.#hasDispose = !!this.#dispose\n    this.#hasDisposeAfter = !!this.#disposeAfter\n\n    this.noDisposeOnSet = !!noDisposeOnSet\n    this.noUpdateTTL = !!noUpdateTTL\n    this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection\n    this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection\n    this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort\n    this.ignoreFetchAbort = !!ignoreFetchAbort\n\n    // NB: maxEntrySize is set to maxSize if it's set\n    if (this.maxEntrySize !== 0) {\n      if (this.#maxSize !== 0) {\n        if (!isPosInt(this.#maxSize)) {\n          throw new TypeError(\n            'maxSize must be a positive integer if specified'\n          )\n        }\n      }\n      if (!isPosInt(this.maxEntrySize)) {\n        throw new TypeError(\n          'maxEntrySize must be a positive integer if specified'\n        )\n      }\n      this.#initializeSizeTracking()\n    }\n\n    this.allowStale = !!allowStale\n    this.noDeleteOnStaleGet = !!noDeleteOnStaleGet\n    this.updateAgeOnGet = !!updateAgeOnGet\n    this.updateAgeOnHas = !!updateAgeOnHas\n    this.ttlResolution =\n      isPosInt(ttlResolution) || ttlResolution === 0\n        ? ttlResolution\n        : 1\n    this.ttlAutopurge = !!ttlAutopurge\n    this.ttl = ttl || 0\n    if (this.ttl) {\n      if (!isPosInt(this.ttl)) {\n        throw new TypeError(\n          'ttl must be a positive integer if specified'\n        )\n      }\n      this.#initializeTTLTracking()\n    }\n\n    // do not allow completely unbounded caches\n    if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) {\n      throw new TypeError(\n        'At least one of max, maxSize, or ttl is required'\n      )\n    }\n    if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {\n      const code = 'LRU_CACHE_UNBOUNDED'\n      if (shouldWarn(code)) {\n        warned.add(code)\n        const msg =\n          'TTL caching without ttlAutopurge, max, or maxSize can ' +\n          'result in unbounded memory consumption.'\n        emitWarning(msg, 'UnboundedCacheWarning', code, LRUCache)\n      }\n    }\n  }\n\n  /**\n   * Return the number of ms left in the item's TTL. If item is not in cache,\n   * returns `0`. Returns `Infinity` if item is in cache without a defined TTL.\n   */\n  getRemainingTTL(key: K) {\n    return this.#keyMap.has(key) ? Infinity : 0\n  }\n\n  #initializeTTLTracking() {\n    const ttls = new ZeroArray(this.#max)\n    const starts = new ZeroArray(this.#max)\n    this.#ttls = ttls\n    this.#starts = starts\n\n    this.#setItemTTL = (index, ttl, start = perf.now()) => {\n      starts[index] = ttl !== 0 ? start : 0\n      ttls[index] = ttl\n      if (ttl !== 0 && this.ttlAutopurge) {\n        const t = setTimeout(() => {\n          if (this.#isStale(index)) {\n            this.#delete(this.#keyList[index] as K, 'expire')\n          }\n        }, ttl + 1)\n        // unref() not supported on all platforms\n        /* c8 ignore start */\n        if (t.unref) {\n          t.unref()\n        }\n        /* c8 ignore stop */\n      }\n    }\n\n    this.#updateItemAge = index => {\n      starts[index] = ttls[index] !== 0 ? perf.now() : 0\n    }\n\n    this.#statusTTL = (status, index) => {\n      if (ttls[index]) {\n        const ttl = ttls[index]\n        const start = starts[index]\n        /* c8 ignore next */\n        if (!ttl || !start) return\n        status.ttl = ttl\n        status.start = start\n        status.now = cachedNow || getNow()\n        const age = status.now - start\n        status.remainingTTL = ttl - age\n      }\n    }\n\n    // debounce calls to perf.now() to 1s so we're not hitting\n    // that costly call repeatedly.\n    let cachedNow = 0\n    const getNow = () => {\n      const n = perf.now()\n      if (this.ttlResolution > 0) {\n        cachedNow = n\n        const t = setTimeout(\n          () => (cachedNow = 0),\n          this.ttlResolution\n        )\n        // not available on all platforms\n        /* c8 ignore start */\n        if (t.unref) {\n          t.unref()\n        }\n        /* c8 ignore stop */\n      }\n      return n\n    }\n\n    this.getRemainingTTL = key => {\n      const index = this.#keyMap.get(key)\n      if (index === undefined) {\n        return 0\n      }\n      const ttl = ttls[index]\n      const start = starts[index]\n      if (!ttl || !start) {\n        return Infinity\n      }\n      const age = (cachedNow || getNow()) - start\n      return ttl - age\n    }\n\n    this.#isStale = index => {\n      const s = starts[index]\n      const t = ttls[index]\n      return !!t && !!s && (cachedNow || getNow()) - s > t\n    }\n  }\n\n  // conditionally set private methods related to TTL\n  #updateItemAge: (index: Index) => void = () => {}\n  #statusTTL: (status: LRUCache.Status<V>, index: Index) => void =\n    () => {}\n  #setItemTTL: (\n    index: Index,\n    ttl: LRUCache.Milliseconds,\n    start?: LRUCache.Milliseconds\n    // ignore because we never call this if we're not already in TTL mode\n    /* c8 ignore start */\n  ) => void = () => {}\n  /* c8 ignore stop */\n\n  #isStale: (index: Index) => boolean = () => false\n\n  #initializeSizeTracking() {\n    const sizes = new ZeroArray(this.#max)\n    this.#calculatedSize = 0\n    this.#sizes = sizes\n    this.#removeItemSize = index => {\n      this.#calculatedSize -= sizes[index] as number\n      sizes[index] = 0\n    }\n    this.#requireSize = (k, v, size, sizeCalculation) => {\n      // provisionally accept background fetches.\n      // actual value size will be checked when they return.\n      if (this.#isBackgroundFetch(v)) {\n        return 0\n      }\n      if (!isPosInt(size)) {\n        if (sizeCalculation) {\n          if (typeof sizeCalculation !== 'function') {\n            throw new TypeError('sizeCalculation must be a function')\n          }\n          size = sizeCalculation(v, k)\n          if (!isPosInt(size)) {\n            throw new TypeError(\n              'sizeCalculation return invalid (expect positive integer)'\n            )\n          }\n        } else {\n          throw new TypeError(\n            'invalid size value (must be positive integer). ' +\n              'When maxSize or maxEntrySize is used, sizeCalculation ' +\n              'or size must be set.'\n          )\n        }\n      }\n      return size\n    }\n    this.#addItemSize = (\n      index: Index,\n      size: LRUCache.Size,\n      status?: LRUCache.Status<V>\n    ) => {\n      sizes[index] = size\n      if (this.#maxSize) {\n        const maxSize = this.#maxSize - (sizes[index] as number)\n        while (this.#calculatedSize > maxSize) {\n          this.#evict(true)\n        }\n      }\n      this.#calculatedSize += sizes[index] as number\n      if (status) {\n        status.entrySize = size\n        status.totalCalculatedSize = this.#calculatedSize\n      }\n    }\n  }\n\n  #removeItemSize: (index: Index) => void = _i => {}\n  #addItemSize: (\n    index: Index,\n    size: LRUCache.Size,\n    status?: LRUCache.Status<V>\n  ) => void = (_i, _s, _st) => {}\n  #requireSize: (\n    k: K,\n    v: V | BackgroundFetch<V>,\n    size?: LRUCache.Size,\n    sizeCalculation?: LRUCache.SizeCalculator<K, V>\n  ) => LRUCache.Size = (\n    _k: K,\n    _v: V | BackgroundFetch<V>,\n    size?: LRUCache.Size,\n    sizeCalculation?: LRUCache.SizeCalculator<K, V>\n  ) => {\n    if (size || sizeCalculation) {\n      throw new TypeError(\n        'cannot set size without setting maxSize or maxEntrySize on cache'\n      )\n    }\n    return 0\n  };\n\n  *#indexes({ allowStale = this.allowStale } = {}) {\n    if (this.#size) {\n      for (let i = this.#tail; true; ) {\n        if (!this.#isValidIndex(i)) {\n          break\n        }\n        if (allowStale || !this.#isStale(i)) {\n          yield i\n        }\n        if (i === this.#head) {\n          break\n        } else {\n          i = this.#prev[i] as Index\n        }\n      }\n    }\n  }\n\n  *#rindexes({ allowStale = this.allowStale } = {}) {\n    if (this.#size) {\n      for (let i = this.#head; true; ) {\n        if (!this.#isValidIndex(i)) {\n          break\n        }\n        if (allowStale || !this.#isStale(i)) {\n          yield i\n        }\n        if (i === this.#tail) {\n          break\n        } else {\n          i = this.#next[i] as Index\n        }\n      }\n    }\n  }\n\n  #isValidIndex(index: Index) {\n    return (\n      index !== undefined &&\n      this.#keyMap.get(this.#keyList[index] as K) === index\n    )\n  }\n\n  /**\n   * Return a generator yielding `[key, value]` pairs,\n   * in order from most recently used to least recently used.\n   */\n  *entries() {\n    for (const i of this.#indexes()) {\n      if (\n        this.#valList[i] !== undefined &&\n        this.#keyList[i] !== undefined &&\n        !this.#isBackgroundFetch(this.#valList[i])\n      ) {\n        yield [this.#keyList[i], this.#valList[i]] as [K, V]\n      }\n    }\n  }\n\n  /**\n   * Inverse order version of {@link LRUCache.entries}\n   *\n   * Return a generator yielding `[key, value]` pairs,\n   * in order from least recently used to most recently used.\n   */\n  *rentries() {\n    for (const i of this.#rindexes()) {\n      if (\n        this.#valList[i] !== undefined &&\n        this.#keyList[i] !== undefined &&\n        !this.#isBackgroundFetch(this.#valList[i])\n      ) {\n        yield [this.#keyList[i], this.#valList[i]]\n      }\n    }\n  }\n\n  /**\n   * Return a generator yielding the keys in the cache,\n   * in order from most recently used to least recently used.\n   */\n  *keys() {\n    for (const i of this.#indexes()) {\n      const k = this.#keyList[i]\n      if (\n        k !== undefined &&\n        !this.#isBackgroundFetch(this.#valList[i])\n      ) {\n        yield k\n      }\n    }\n  }\n\n  /**\n   * Inverse order version of {@link LRUCache.keys}\n   *\n   * Return a generator yielding the keys in the cache,\n   * in order from least recently used to most recently used.\n   */\n  *rkeys() {\n    for (const i of this.#rindexes()) {\n      const k = this.#keyList[i]\n      if (\n        k !== undefined &&\n        !this.#isBackgroundFetch(this.#valList[i])\n      ) {\n        yield k\n      }\n    }\n  }\n\n  /**\n   * Return a generator yielding the values in the cache,\n   * in order from most recently used to least recently used.\n   */\n  *values() {\n    for (const i of this.#indexes()) {\n      const v = this.#valList[i]\n      if (\n        v !== undefined &&\n        !this.#isBackgroundFetch(this.#valList[i])\n      ) {\n        yield this.#valList[i] as V\n      }\n    }\n  }\n\n  /**\n   * Inverse order version of {@link LRUCache.values}\n   *\n   * Return a generator yielding the values in the cache,\n   * in order from least recently used to most recently used.\n   */\n  *rvalues() {\n    for (const i of this.#rindexes()) {\n      const v = this.#valList[i]\n      if (\n        v !== undefined &&\n        !this.#isBackgroundFetch(this.#valList[i])\n      ) {\n        yield this.#valList[i]\n      }\n    }\n  }\n\n  /**\n   * Iterating over the cache itself yields the same results as\n   * {@link LRUCache.entries}\n   */\n  [Symbol.iterator]() {\n    return this.entries()\n  }\n\n  /**\n   * A String value that is used in the creation of the default string\n   * description of an object. Called by the built-in method\n   * `Object.prototype.toString`.\n   */\n  [Symbol.toStringTag] = 'LRUCache'\n\n  /**\n   * Find a value for which the supplied fn method returns a truthy value,\n   * similar to `Array.find()`. fn is called as `fn(value, key, cache)`.\n   */\n  find(\n    fn: (v: V, k: K, self: LRUCache<K, V, FC>) => boolean,\n    getOptions: LRUCache.GetOptions<K, V, FC> = {}\n  ) {\n    for (const i of this.#indexes()) {\n      const v = this.#valList[i]\n      const value = this.#isBackgroundFetch(v)\n        ? v.__staleWhileFetching\n        : v\n      if (value === undefined) continue\n      if (fn(value, this.#keyList[i] as K, this)) {\n        return this.get(this.#keyList[i] as K, getOptions)\n      }\n    }\n  }\n\n  /**\n   * Call the supplied function on each item in the cache, in order from most\n   * recently used to least recently used.\n   *\n   * `fn` is called as `fn(value, key, cache)`.\n   *\n   * If `thisp` is provided, function will be called in the `this`-context of\n   * the provided object, or the cache if no `thisp` object is provided.\n   *\n   * Does not update age or recenty of use, or iterate over stale values.\n   */\n  forEach(\n    fn: (v: V, k: K, self: LRUCache<K, V, FC>) => any,\n    thisp: any = this\n  ) {\n    for (const i of this.#indexes()) {\n      const v = this.#valList[i]\n      const value = this.#isBackgroundFetch(v)\n        ? v.__staleWhileFetching\n        : v\n      if (value === undefined) continue\n      fn.call(thisp, value, this.#keyList[i] as K, this)\n    }\n  }\n\n  /**\n   * The same as {@link LRUCache.forEach} but items are iterated over in\n   * reverse order.  (ie, less recently used items are iterated over first.)\n   */\n  rforEach(\n    fn: (v: V, k: K, self: LRUCache<K, V, FC>) => any,\n    thisp: any = this\n  ) {\n    for (const i of this.#rindexes()) {\n      const v = this.#valList[i]\n      const value = this.#isBackgroundFetch(v)\n        ? v.__staleWhileFetching\n        : v\n      if (value === undefined) continue\n      fn.call(thisp, value, this.#keyList[i] as K, this)\n    }\n  }\n\n  /**\n   * Delete any stale entries. Returns true if anything was removed,\n   * false otherwise.\n   */\n  purgeStale() {\n    let deleted = false\n    for (const i of this.#rindexes({ allowStale: true })) {\n      if (this.#isStale(i)) {\n        this.#delete(this.#keyList[i] as K, 'expire')\n        deleted = true\n      }\n    }\n    return deleted\n  }\n\n  /**\n   * Get the extended info about a given entry, to get its value, size, and\n   * TTL info simultaneously. Returns `undefined` if the key is not present.\n   *\n   * Unlike {@link LRUCache#dump}, which is designed to be portable and survive\n   * serialization, the `start` value is always the current timestamp, and the\n   * `ttl` is a calculated remaining time to live (negative if expired).\n   *\n   * Always returns stale values, if their info is found in the cache, so be\n   * sure to check for expirations (ie, a negative {@link LRUCache.Entry#ttl})\n   * if relevant.\n   */\n  info(key: K): LRUCache.Entry<V> | undefined {\n    const i = this.#keyMap.get(key)\n    if (i === undefined) return undefined\n    const v = this.#valList[i]\n    const value: V | undefined = this.#isBackgroundFetch(v)\n      ? v.__staleWhileFetching\n      : v\n    if (value === undefined) return undefined\n    const entry: LRUCache.Entry<V> = { value }\n    if (this.#ttls && this.#starts) {\n      const ttl = this.#ttls[i]\n      const start = this.#starts[i]\n      if (ttl && start) {\n        const remain = ttl - (perf.now() - start)\n        entry.ttl = remain\n        entry.start = Date.now()\n      }\n    }\n    if (this.#sizes) {\n      entry.size = this.#sizes[i]\n    }\n    return entry\n  }\n\n  /**\n   * Return an array of [key, {@link LRUCache.Entry}] tuples which can be\n   * passed to {@link LRUCache#load}.\n   *\n   * The `start` fields are calculated relative to a portable `Date.now()`\n   * timestamp, even if `performance.now()` is available.\n   *\n   * Stale entries are always included in the `dump`, even if\n   * {@link LRUCache.OptionsBase.allowStale} is false.\n   *\n   * Note: this returns an actual array, not a generator, so it can be more\n   * easily passed around.\n   */\n  dump() {\n    const arr: [K, LRUCache.Entry<V>][] = []\n    for (const i of this.#indexes({ allowStale: true })) {\n      const key = this.#keyList[i]\n      const v = this.#valList[i]\n      const value: V | undefined = this.#isBackgroundFetch(v)\n        ? v.__staleWhileFetching\n        : v\n      if (value === undefined || key === undefined) continue\n      const entry: LRUCache.Entry<V> = { value }\n      if (this.#ttls && this.#starts) {\n        entry.ttl = this.#ttls[i]\n        // always dump the start relative to a portable timestamp\n        // it's ok for this to be a bit slow, it's a rare operation.\n        const age = perf.now() - (this.#starts[i] as number)\n        entry.start = Math.floor(Date.now() - age)\n      }\n      if (this.#sizes) {\n        entry.size = this.#sizes[i]\n      }\n      arr.unshift([key, entry])\n    }\n    return arr\n  }\n\n  /**\n   * Reset the cache and load in the items in entries in the order listed.\n   *\n   * The shape of the resulting cache may be different if the same options are\n   * not used in both caches.\n   *\n   * The `start` fields are assumed to be calculated relative to a portable\n   * `Date.now()` timestamp, even if `performance.now()` is available.\n   */\n  load(arr: [K, LRUCache.Entry<V>][]) {\n    this.clear()\n    for (const [key, entry] of arr) {\n      if (entry.start) {\n        // entry.start is a portable timestamp, but we may be using\n        // node's performance.now(), so calculate the offset, so that\n        // we get the intended remaining TTL, no matter how long it's\n        // been on ice.\n        //\n        // it's ok for this to be a bit slow, it's a rare operation.\n        const age = Date.now() - entry.start\n        entry.start = perf.now() - age\n      }\n      this.set(key, entry.value, entry)\n    }\n  }\n\n  /**\n   * Add a value to the cache.\n   *\n   * Note: if `undefined` is specified as a value, this is an alias for\n   * {@link LRUCache#delete}\n   *\n   * Fields on the {@link LRUCache.SetOptions} options param will override\n   * their corresponding values in the constructor options for the scope\n   * of this single `set()` operation.\n   *\n   * If `start` is provided, then that will set the effective start\n   * time for the TTL calculation. Note that this must be a previous\n   * value of `performance.now()` if supported, or a previous value of\n   * `Date.now()` if not.\n   *\n   * Options object may also include `size`, which will prevent\n   * calling the `sizeCalculation` function and just use the specified\n   * number if it is a positive integer, and `noDisposeOnSet` which\n   * will prevent calling a `dispose` function in the case of\n   * overwrites.\n   *\n   * If the `size` (or return value of `sizeCalculation`) for a given\n   * entry is greater than `maxEntrySize`, then the item will not be\n   * added to the cache.\n   *\n   * Will update the recency of the entry.\n   *\n   * If the value is `undefined`, then this is an alias for\n   * `cache.delete(key)`. `undefined` is never stored in the cache.\n   */\n  set(\n    k: K,\n    v: V | BackgroundFetch<V> | undefined,\n    setOptions: LRUCache.SetOptions<K, V, FC> = {}\n  ) {\n    if (v === undefined) {\n      this.delete(k)\n      return this\n    }\n    const {\n      ttl = this.ttl,\n      start,\n      noDisposeOnSet = this.noDisposeOnSet,\n      sizeCalculation = this.sizeCalculation,\n      status,\n    } = setOptions\n    let { noUpdateTTL = this.noUpdateTTL } = setOptions\n\n    const size = this.#requireSize(\n      k,\n      v,\n      setOptions.size || 0,\n      sizeCalculation\n    )\n    // if the item doesn't fit, don't do anything\n    // NB: maxEntrySize set to maxSize by default\n    if (this.maxEntrySize && size > this.maxEntrySize) {\n      if (status) {\n        status.set = 'miss'\n        status.maxEntrySizeExceeded = true\n      }\n      // have to delete, in case something is there already.\n      this.#delete(k, 'set')\n      return this\n    }\n    let index = this.#size === 0 ? undefined : this.#keyMap.get(k)\n    if (index === undefined) {\n      // addition\n      index = (\n        this.#size === 0\n          ? this.#tail\n          : this.#free.length !== 0\n          ? this.#free.pop()\n          : this.#size === this.#max\n          ? this.#evict(false)\n          : this.#size\n      ) as Index\n      this.#keyList[index] = k\n      this.#valList[index] = v\n      this.#keyMap.set(k, index)\n      this.#next[this.#tail] = index\n      this.#prev[index] = this.#tail\n      this.#tail = index\n      this.#size++\n      this.#addItemSize(index, size, status)\n      if (status) status.set = 'add'\n      noUpdateTTL = false\n    } else {\n      // update\n      this.#moveToTail(index)\n      const oldVal = this.#valList[index] as V | BackgroundFetch<V>\n      if (v !== oldVal) {\n        if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {\n          oldVal.__abortController.abort(new Error('replaced'))\n          const { __staleWhileFetching: s } = oldVal\n          if (s !== undefined && !noDisposeOnSet) {\n            if (this.#hasDispose) {\n              this.#dispose?.(s as V, k, 'set')\n            }\n            if (this.#hasDisposeAfter) {\n              this.#disposed?.push([s as V, k, 'set'])\n            }\n          }\n        } else if (!noDisposeOnSet) {\n          if (this.#hasDispose) {\n            this.#dispose?.(oldVal as V, k, 'set')\n          }\n          if (this.#hasDisposeAfter) {\n            this.#disposed?.push([oldVal as V, k, 'set'])\n          }\n        }\n        this.#removeItemSize(index)\n        this.#addItemSize(index, size, status)\n        this.#valList[index] = v\n        if (status) {\n          status.set = 'replace'\n          const oldValue =\n            oldVal && this.#isBackgroundFetch(oldVal)\n              ? oldVal.__staleWhileFetching\n              : oldVal\n          if (oldValue !== undefined) status.oldValue = oldValue\n        }\n      } else if (status) {\n        status.set = 'update'\n      }\n    }\n    if (ttl !== 0 && !this.#ttls) {\n      this.#initializeTTLTracking()\n    }\n    if (this.#ttls) {\n      if (!noUpdateTTL) {\n        this.#setItemTTL(index, ttl, start)\n      }\n      if (status) this.#statusTTL(status, index)\n    }\n    if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {\n      const dt = this.#disposed\n      let task: DisposeTask<K, V> | undefined\n      while ((task = dt?.shift())) {\n        this.#disposeAfter?.(...task)\n      }\n    }\n    return this\n  }\n\n  /**\n   * Evict the least recently used item, returning its value or\n   * `undefined` if cache is empty.\n   */\n  pop(): V | undefined {\n    try {\n      while (this.#size) {\n        const val = this.#valList[this.#head]\n        this.#evict(true)\n        if (this.#isBackgroundFetch(val)) {\n          if (val.__staleWhileFetching) {\n            return val.__staleWhileFetching\n          }\n        } else if (val !== undefined) {\n          return val\n        }\n      }\n    } finally {\n      if (this.#hasDisposeAfter && this.#disposed) {\n        const dt = this.#disposed\n        let task: DisposeTask<K, V> | undefined\n        while ((task = dt?.shift())) {\n          this.#disposeAfter?.(...task)\n        }\n      }\n    }\n  }\n\n  #evict(free: boolean) {\n    const head = this.#head\n    const k = this.#keyList[head] as K\n    const v = this.#valList[head] as V\n    if (this.#hasFetchMethod && this.#isBackgroundFetch(v)) {\n      v.__abortController.abort(new Error('evicted'))\n    } else if (this.#hasDispose || this.#hasDisposeAfter) {\n      if (this.#hasDispose) {\n        this.#dispose?.(v, k, 'evict')\n      }\n      if (this.#hasDisposeAfter) {\n        this.#disposed?.push([v, k, 'evict'])\n      }\n    }\n    this.#removeItemSize(head)\n    // if we aren't about to use the index, then null these out\n    if (free) {\n      this.#keyList[head] = undefined\n      this.#valList[head] = undefined\n      this.#free.push(head)\n    }\n    if (this.#size === 1) {\n      this.#head = this.#tail = 0 as Index\n      this.#free.length = 0\n    } else {\n      this.#head = this.#next[head] as Index\n    }\n    this.#keyMap.delete(k)\n    this.#size--\n    return head\n  }\n\n  /**\n   * Check if a key is in the cache, without updating the recency of use.\n   * Will return false if the item is stale, even though it is technically\n   * in the cache.\n   *\n   * Check if a key is in the cache, without updating the recency of\n   * use. Age is updated if {@link LRUCache.OptionsBase.updateAgeOnHas} is set\n   * to `true` in either the options or the constructor.\n   *\n   * Will return `false` if the item is stale, even though it is technically in\n   * the cache. The difference can be determined (if it matters) by using a\n   * `status` argument, and inspecting the `has` field.\n   *\n   * Will not update item age unless\n   * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.\n   */\n  has(k: K, hasOptions: LRUCache.HasOptions<K, V, FC> = {}) {\n    const { updateAgeOnHas = this.updateAgeOnHas, status } =\n      hasOptions\n    const index = this.#keyMap.get(k)\n    if (index !== undefined) {\n      const v = this.#valList[index]\n      if (\n        this.#isBackgroundFetch(v) &&\n        v.__staleWhileFetching === undefined\n      ) {\n        return false\n      }\n      if (!this.#isStale(index)) {\n        if (updateAgeOnHas) {\n          this.#updateItemAge(index)\n        }\n        if (status) {\n          status.has = 'hit'\n          this.#statusTTL(status, index)\n        }\n        return true\n      } else if (status) {\n        status.has = 'stale'\n        this.#statusTTL(status, index)\n      }\n    } else if (status) {\n      status.has = 'miss'\n    }\n    return false\n  }\n\n  /**\n   * Like {@link LRUCache#get} but doesn't update recency or delete stale\n   * items.\n   *\n   * Returns `undefined` if the item is stale, unless\n   * {@link LRUCache.OptionsBase.allowStale} is set.\n   */\n  peek(k: K, peekOptions: LRUCache.PeekOptions<K, V, FC> = {}) {\n    const { allowStale = this.allowStale } = peekOptions\n    const index = this.#keyMap.get(k)\n    if (\n      index === undefined ||\n      (!allowStale && this.#isStale(index))\n    ) {\n      return\n    }\n    const v = this.#valList[index]\n    // either stale and allowed, or forcing a refresh of non-stale value\n    return this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v\n  }\n\n  #backgroundFetch(\n    k: K,\n    index: Index | undefined,\n    options: LRUCache.FetchOptions<K, V, FC>,\n    context: any\n  ): BackgroundFetch<V> {\n    const v = index === undefined ? undefined : this.#valList[index]\n    if (this.#isBackgroundFetch(v)) {\n      return v\n    }\n\n    const ac = new AC()\n    const { signal } = options\n    // when/if our AC signals, then stop listening to theirs.\n    signal?.addEventListener('abort', () => ac.abort(signal.reason), {\n      signal: ac.signal,\n    })\n\n    const fetchOpts = {\n      signal: ac.signal,\n      options,\n      context,\n    }\n\n    const cb = (\n      v: V | undefined,\n      updateCache = false\n    ): V | undefined => {\n      const { aborted } = ac.signal\n      const ignoreAbort = options.ignoreFetchAbort && v !== undefined\n      if (options.status) {\n        if (aborted && !updateCache) {\n          options.status.fetchAborted = true\n          options.status.fetchError = ac.signal.reason\n          if (ignoreAbort) options.status.fetchAbortIgnored = true\n        } else {\n          options.status.fetchResolved = true\n        }\n      }\n      if (aborted && !ignoreAbort && !updateCache) {\n        return fetchFail(ac.signal.reason)\n      }\n      // either we didn't abort, and are still here, or we did, and ignored\n      const bf = p as BackgroundFetch<V>\n      if (this.#valList[index as Index] === p) {\n        if (v === undefined) {\n          if (bf.__staleWhileFetching) {\n            this.#valList[index as Index] = bf.__staleWhileFetching\n          } else {\n            this.#delete(k, 'fetch')\n          }\n        } else {\n          if (options.status) options.status.fetchUpdated = true\n          this.set(k, v, fetchOpts.options)\n        }\n      }\n      return v\n    }\n\n    const eb = (er: any) => {\n      if (options.status) {\n        options.status.fetchRejected = true\n        options.status.fetchError = er\n      }\n      return fetchFail(er)\n    }\n\n    const fetchFail = (er: any): V | undefined => {\n      const { aborted } = ac.signal\n      const allowStaleAborted =\n        aborted && options.allowStaleOnFetchAbort\n      const allowStale =\n        allowStaleAborted || options.allowStaleOnFetchRejection\n      const noDelete = allowStale || options.noDeleteOnFetchRejection\n      const bf = p as BackgroundFetch<V>\n      if (this.#valList[index as Index] === p) {\n        // if we allow stale on fetch rejections, then we need to ensure that\n        // the stale value is not removed from the cache when the fetch fails.\n        const del = !noDelete || bf.__staleWhileFetching === undefined\n        if (del) {\n          this.#delete(k, 'fetch')\n        } else if (!allowStaleAborted) {\n          // still replace the *promise* with the stale value,\n          // since we are done with the promise at this point.\n          // leave it untouched if we're still waiting for an\n          // aborted background fetch that hasn't yet returned.\n          this.#valList[index as Index] = bf.__staleWhileFetching\n        }\n      }\n      if (allowStale) {\n        if (options.status && bf.__staleWhileFetching !== undefined) {\n          options.status.returnedStale = true\n        }\n        return bf.__staleWhileFetching\n      } else if (bf.__returned === bf) {\n        throw er\n      }\n    }\n\n    const pcall = (\n      res: (v: V | undefined) => void,\n      rej: (e: any) => void\n    ) => {\n      const fmp = this.#fetchMethod?.(k, v, fetchOpts)\n      if (fmp && fmp instanceof Promise) {\n        fmp.then(v => res(v === undefined ? undefined : v), rej)\n      }\n      // ignored, we go until we finish, regardless.\n      // defer check until we are actually aborting,\n      // so fetchMethod can override.\n      ac.signal.addEventListener('abort', () => {\n        if (\n          !options.ignoreFetchAbort ||\n          options.allowStaleOnFetchAbort\n        ) {\n          res(undefined)\n          // when it eventually resolves, update the cache.\n          if (options.allowStaleOnFetchAbort) {\n            res = v => cb(v, true)\n          }\n        }\n      })\n    }\n\n    if (options.status) options.status.fetchDispatched = true\n    const p = new Promise(pcall).then(cb, eb)\n    const bf: BackgroundFetch<V> = Object.assign(p, {\n      __abortController: ac,\n      __staleWhileFetching: v,\n      __returned: undefined,\n    })\n\n    if (index === undefined) {\n      // internal, don't expose status.\n      this.set(k, bf, { ...fetchOpts.options, status: undefined })\n      index = this.#keyMap.get(k)\n    } else {\n      this.#valList[index] = bf\n    }\n    return bf\n  }\n\n  #isBackgroundFetch(p: any): p is BackgroundFetch<V> {\n    if (!this.#hasFetchMethod) return false\n    const b = p as BackgroundFetch<V>\n    return (\n      !!b &&\n      b instanceof Promise &&\n      b.hasOwnProperty('__staleWhileFetching') &&\n      b.__abortController instanceof AC\n    )\n  }\n\n  /**\n   * Make an asynchronous cached fetch using the\n   * {@link LRUCache.OptionsBase.fetchMethod} function.\n   *\n   * If the value is in the cache and not stale, then the returned\n   * Promise resolves to the value.\n   *\n   * If not in the cache, or beyond its TTL staleness, then\n   * `fetchMethod(key, staleValue, { options, signal, context })` is\n   * called, and the value returned will be added to the cache once\n   * resolved.\n   *\n   * If called with `allowStale`, and an asynchronous fetch is\n   * currently in progress to reload a stale value, then the former\n   * stale value will be returned.\n   *\n   * If called with `forceRefresh`, then the cached item will be\n   * re-fetched, even if it is not stale. However, if `allowStale` is also\n   * set, then the old value will still be returned. This is useful\n   * in cases where you want to force a reload of a cached value. If\n   * a background fetch is already in progress, then `forceRefresh`\n   * has no effect.\n   *\n   * If multiple fetches for the same key are issued, then they will all be\n   * coalesced into a single call to fetchMethod.\n   *\n   * Note that this means that handling options such as\n   * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort},\n   * {@link LRUCache.FetchOptions.signal},\n   * and {@link LRUCache.OptionsBase.allowStaleOnFetchRejection} will be\n   * determined by the FIRST fetch() call for a given key.\n   *\n   * This is a known (fixable) shortcoming which will be addresed on when\n   * someone complains about it, as the fix would involve added complexity and\n   * may not be worth the costs for this edge case.\n   *\n   * If {@link LRUCache.OptionsBase.fetchMethod} is not specified, then this is\n   * effectively an alias for `Promise.resolve(cache.get(key))`.\n   *\n   * When the fetch method resolves to a value, if the fetch has not\n   * been aborted due to deletion, eviction, or being overwritten,\n   * then it is added to the cache using the options provided.\n   *\n   * If the key is evicted or deleted before the `fetchMethod`\n   * resolves, then the AbortSignal passed to the `fetchMethod` will\n   * receive an `abort` event, and the promise returned by `fetch()`\n   * will reject with the reason for the abort.\n   *\n   * If a `signal` is passed to the `fetch()` call, then aborting the\n   * signal will abort the fetch and cause the `fetch()` promise to\n   * reject with the reason provided.\n   *\n   * **Setting `context`**\n   *\n   * If an `FC` type is set to a type other than `unknown`, `void`, or\n   * `undefined` in the {@link LRUCache} constructor, then all\n   * calls to `cache.fetch()` _must_ provide a `context` option. If\n   * set to `undefined` or `void`, then calls to fetch _must not_\n   * provide a `context` option.\n   *\n   * The `context` param allows you to provide arbitrary data that\n   * might be relevant in the course of fetching the data. It is only\n   * relevant for the course of a single `fetch()` operation, and\n   * discarded afterwards.\n   *\n   * **Note: `fetch()` calls are inflight-unique**\n   *\n   * If you call `fetch()` multiple times with the same key value,\n   * then every call after the first will resolve on the same\n   * promise<sup>1</sup>,\n   * _even if they have different settings that would otherwise change\n   * the behavior of the fetch_, such as `noDeleteOnFetchRejection`\n   * or `ignoreFetchAbort`.\n   *\n   * In most cases, this is not a problem (in fact, only fetching\n   * something once is what you probably want, if you're caching in\n   * the first place). If you are changing the fetch() options\n   * dramatically between runs, there's a good chance that you might\n   * be trying to fit divergent semantics into a single object, and\n   * would be better off with multiple cache instances.\n   *\n   * **1**: Ie, they're not the \"same Promise\", but they resolve at\n   * the same time, because they're both waiting on the same\n   * underlying fetchMethod response.\n   */\n\n  fetch(\n    k: K,\n    fetchOptions: unknown extends FC\n      ? LRUCache.FetchOptions<K, V, FC>\n      : FC extends undefined | void\n      ? LRUCache.FetchOptionsNoContext<K, V>\n      : LRUCache.FetchOptionsWithContext<K, V, FC>\n  ): Promise<undefined | V>\n\n  // this overload not allowed if context is required\n  fetch(\n    k: unknown extends FC\n      ? K\n      : FC extends undefined | void\n      ? K\n      : never,\n    fetchOptions?: unknown extends FC\n      ? LRUCache.FetchOptions<K, V, FC>\n      : FC extends undefined | void\n      ? LRUCache.FetchOptionsNoContext<K, V>\n      : never\n  ): Promise<undefined | V>\n\n  async fetch(\n    k: K,\n    fetchOptions: LRUCache.FetchOptions<K, V, FC> = {}\n  ): Promise<undefined | V> {\n    const {\n      // get options\n      allowStale = this.allowStale,\n      updateAgeOnGet = this.updateAgeOnGet,\n      noDeleteOnStaleGet = this.noDeleteOnStaleGet,\n      // set options\n      ttl = this.ttl,\n      noDisposeOnSet = this.noDisposeOnSet,\n      size = 0,\n      sizeCalculation = this.sizeCalculation,\n      noUpdateTTL = this.noUpdateTTL,\n      // fetch exclusive options\n      noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,\n      allowStaleOnFetchRejection = this.allowStaleOnFetchRejection,\n      ignoreFetchAbort = this.ignoreFetchAbort,\n      allowStaleOnFetchAbort = this.allowStaleOnFetchAbort,\n      context,\n      forceRefresh = false,\n      status,\n      signal,\n    } = fetchOptions\n\n    if (!this.#hasFetchMethod) {\n      if (status) status.fetch = 'get'\n      return this.get(k, {\n        allowStale,\n        updateAgeOnGet,\n        noDeleteOnStaleGet,\n        status,\n      })\n    }\n\n    const options = {\n      allowStale,\n      updateAgeOnGet,\n      noDeleteOnStaleGet,\n      ttl,\n      noDisposeOnSet,\n      size,\n      sizeCalculation,\n      noUpdateTTL,\n      noDeleteOnFetchRejection,\n      allowStaleOnFetchRejection,\n      allowStaleOnFetchAbort,\n      ignoreFetchAbort,\n      status,\n      signal,\n    }\n\n    let index = this.#keyMap.get(k)\n    if (index === undefined) {\n      if (status) status.fetch = 'miss'\n      const p = this.#backgroundFetch(k, index, options, context)\n      return (p.__returned = p)\n    } else {\n      // in cache, maybe already fetching\n      const v = this.#valList[index]\n      if (this.#isBackgroundFetch(v)) {\n        const stale =\n          allowStale && v.__staleWhileFetching !== undefined\n        if (status) {\n          status.fetch = 'inflight'\n          if (stale) status.returnedStale = true\n        }\n        return stale ? v.__staleWhileFetching : (v.__returned = v)\n      }\n\n      // if we force a refresh, that means do NOT serve the cached value,\n      // unless we are already in the process of refreshing the cache.\n      const isStale = this.#isStale(index)\n      if (!forceRefresh && !isStale) {\n        if (status) status.fetch = 'hit'\n        this.#moveToTail(index)\n        if (updateAgeOnGet) {\n          this.#updateItemAge(index)\n        }\n        if (status) this.#statusTTL(status, index)\n        return v\n      }\n\n      // ok, it is stale or a forced refresh, and not already fetching.\n      // refresh the cache.\n      const p = this.#backgroundFetch(k, index, options, context)\n      const hasStale = p.__staleWhileFetching !== undefined\n      const staleVal = hasStale && allowStale\n      if (status) {\n        status.fetch = isStale ? 'stale' : 'refresh'\n        if (staleVal && isStale) status.returnedStale = true\n      }\n      return staleVal ? p.__staleWhileFetching : (p.__returned = p)\n    }\n  }\n\n  /**\n   * In some cases, `cache.fetch()` may resolve to `undefined`, either because\n   * a {@link LRUCache.OptionsBase#fetchMethod} was not provided (turning\n   * `cache.fetch(k)` into just an async wrapper around `cache.get(k)`) or\n   * because `ignoreFetchAbort` was specified (either to the constructor or\n   * in the {@link LRUCache.FetchOptions}). Also, the\n   * {@link LRUCache.OptionsBase.fetchMethod} may return `undefined` or `void`, making\n   * the test even more complicated.\n   *\n   * Because inferring the cases where `undefined` might be returned are so\n   * cumbersome, but testing for `undefined` can also be annoying, this method\n   * can be used, which will reject if `this.fetch()` resolves to undefined.\n   */\n  forceFetch(\n    k: K,\n    fetchOptions: unknown extends FC\n      ? LRUCache.FetchOptions<K, V, FC>\n      : FC extends undefined | void\n      ? LRUCache.FetchOptionsNoContext<K, V>\n      : LRUCache.FetchOptionsWithContext<K, V, FC>\n  ): Promise<V>\n  // this overload not allowed if context is required\n  forceFetch(\n    k: unknown extends FC\n      ? K\n      : FC extends undefined | void\n      ? K\n      : never,\n    fetchOptions?: unknown extends FC\n      ? LRUCache.FetchOptions<K, V, FC>\n      : FC extends undefined | void\n      ? LRUCache.FetchOptionsNoContext<K, V>\n      : never\n  ): Promise<V>\n  async forceFetch(\n    k: K,\n    fetchOptions: LRUCache.FetchOptions<K, V, FC> = {}\n  ): Promise<V> {\n    const v = await this.fetch(\n      k,\n      fetchOptions as unknown extends FC\n        ? LRUCache.FetchOptions<K, V, FC>\n        : FC extends undefined | void\n        ? LRUCache.FetchOptionsNoContext<K, V>\n        : LRUCache.FetchOptionsWithContext<K, V, FC>\n    )\n    if (v === undefined) throw new Error('fetch() returned undefined')\n    return v\n  }\n\n  /**\n   * If the key is found in the cache, then this is equivalent to\n   * {@link LRUCache#get}. If not, in the cache, then calculate the value using\n   * the {@link LRUCache.OptionsBase.memoMethod}, and add it to the cache.\n   *\n   * If an `FC` type is set to a type other than `unknown`, `void`, or\n   * `undefined` in the LRUCache constructor, then all calls to `cache.memo()`\n   * _must_ provide a `context` option. If set to `undefined` or `void`, then\n   * calls to memo _must not_ provide a `context` option.\n   *\n   * The `context` param allows you to provide arbitrary data that might be\n   * relevant in the course of fetching the data. It is only relevant for the\n   * course of a single `memo()` operation, and discarded afterwards.\n   */\n  memo(\n    k: K,\n    memoOptions: unknown extends FC\n      ? LRUCache.MemoOptions<K, V, FC>\n      : FC extends undefined | void\n      ? LRUCache.MemoOptionsNoContext<K, V>\n      : LRUCache.MemoOptionsWithContext<K, V, FC>\n  ): V\n  // this overload not allowed if context is required\n  memo(\n    k: unknown extends FC\n      ? K\n      : FC extends undefined | void\n      ? K\n      : never,\n    memoOptions?: unknown extends FC\n      ? LRUCache.MemoOptions<K, V, FC>\n      : FC extends undefined | void\n      ? LRUCache.MemoOptionsNoContext<K, V>\n      : never\n  ): V\n  memo(k: K, memoOptions: LRUCache.MemoOptions<K, V, FC> = {}) {\n    const memoMethod = this.#memoMethod\n    if (!memoMethod) {\n      throw new Error('no memoMethod provided to constructor')\n    }\n    const { context, forceRefresh, ...options } = memoOptions\n    const v = this.get(k, options)\n    if (!forceRefresh && v !== undefined) return v\n    const vv = memoMethod(k, v, {\n      options,\n      context,\n    } as LRUCache.MemoizerOptions<K, V, FC>)\n    this.set(k, vv, options)\n    return vv\n  }\n\n  /**\n   * Return a value from the cache. Will update the recency of the cache\n   * entry found.\n   *\n   * If the key is not found, get() will return `undefined`.\n   */\n  get(k: K, getOptions: LRUCache.GetOptions<K, V, FC> = {}) {\n    const {\n      allowStale = this.allowStale,\n      updateAgeOnGet = this.updateAgeOnGet,\n      noDeleteOnStaleGet = this.noDeleteOnStaleGet,\n      status,\n    } = getOptions\n    const index = this.#keyMap.get(k)\n    if (index !== undefined) {\n      const value = this.#valList[index]\n      const fetching = this.#isBackgroundFetch(value)\n      if (status) this.#statusTTL(status, index)\n      if (this.#isStale(index)) {\n        if (status) status.get = 'stale'\n        // delete only if not an in-flight background fetch\n        if (!fetching) {\n          if (!noDeleteOnStaleGet) {\n            this.#delete(k, 'expire')\n          }\n          if (status && allowStale) status.returnedStale = true\n          return allowStale ? value : undefined\n        } else {\n          if (\n            status &&\n            allowStale &&\n            value.__staleWhileFetching !== undefined\n          ) {\n            status.returnedStale = true\n          }\n          return allowStale ? value.__staleWhileFetching : undefined\n        }\n      } else {\n        if (status) status.get = 'hit'\n        // if we're currently fetching it, we don't actually have it yet\n        // it's not stale, which means this isn't a staleWhileRefetching.\n        // If it's not stale, and fetching, AND has a __staleWhileFetching\n        // value, then that means the user fetched with {forceRefresh:true},\n        // so it's safe to return that value.\n        if (fetching) {\n          return value.__staleWhileFetching\n        }\n        this.#moveToTail(index)\n        if (updateAgeOnGet) {\n          this.#updateItemAge(index)\n        }\n        return value\n      }\n    } else if (status) {\n      status.get = 'miss'\n    }\n  }\n\n  #connect(p: Index, n: Index) {\n    this.#prev[n] = p\n    this.#next[p] = n\n  }\n\n  #moveToTail(index: Index): void {\n    // if tail already, nothing to do\n    // if head, move head to next[index]\n    // else\n    //   move next[prev[index]] to next[index] (head has no prev)\n    //   move prev[next[index]] to prev[index]\n    // prev[index] = tail\n    // next[tail] = index\n    // tail = index\n    if (index !== this.#tail) {\n      if (index === this.#head) {\n        this.#head = this.#next[index] as Index\n      } else {\n        this.#connect(\n          this.#prev[index] as Index,\n          this.#next[index] as Index\n        )\n      }\n      this.#connect(this.#tail, index)\n      this.#tail = index\n    }\n  }\n\n  /**\n   * Deletes a key out of the cache.\n   *\n   * Returns true if the key was deleted, false otherwise.\n   */\n  delete(k: K) {\n    return this.#delete(k, 'delete')\n  }\n\n  #delete(k: K, reason: LRUCache.DisposeReason) {\n    let deleted = false\n    if (this.#size !== 0) {\n      const index = this.#keyMap.get(k)\n      if (index !== undefined) {\n        deleted = true\n        if (this.#size === 1) {\n          this.#clear(reason)\n        } else {\n          this.#removeItemSize(index)\n          const v = this.#valList[index]\n          if (this.#isBackgroundFetch(v)) {\n            v.__abortController.abort(new Error('deleted'))\n          } else if (this.#hasDispose || this.#hasDisposeAfter) {\n            if (this.#hasDispose) {\n              this.#dispose?.(v as V, k, reason)\n            }\n            if (this.#hasDisposeAfter) {\n              this.#disposed?.push([v as V, k, reason])\n            }\n          }\n          this.#keyMap.delete(k)\n          this.#keyList[index] = undefined\n          this.#valList[index] = undefined\n          if (index === this.#tail) {\n            this.#tail = this.#prev[index] as Index\n          } else if (index === this.#head) {\n            this.#head = this.#next[index] as Index\n          } else {\n            const pi = this.#prev[index] as number\n            this.#next[pi] = this.#next[index] as number\n            const ni = this.#next[index] as number\n            this.#prev[ni] = this.#prev[index] as number\n          }\n          this.#size--\n          this.#free.push(index)\n        }\n      }\n    }\n    if (this.#hasDisposeAfter && this.#disposed?.length) {\n      const dt = this.#disposed\n      let task: DisposeTask<K, V> | undefined\n      while ((task = dt?.shift())) {\n        this.#disposeAfter?.(...task)\n      }\n    }\n    return deleted\n  }\n\n  /**\n   * Clear the cache entirely, throwing away all values.\n   */\n  clear() {\n    return this.#clear('delete')\n  }\n  #clear(reason: LRUCache.DisposeReason) {\n    for (const index of this.#rindexes({ allowStale: true })) {\n      const v = this.#valList[index]\n      if (this.#isBackgroundFetch(v)) {\n        v.__abortController.abort(new Error('deleted'))\n      } else {\n        const k = this.#keyList[index]\n        if (this.#hasDispose) {\n          this.#dispose?.(v as V, k as K, reason)\n        }\n        if (this.#hasDisposeAfter) {\n          this.#disposed?.push([v as V, k as K, reason])\n        }\n      }\n    }\n\n    this.#keyMap.clear()\n    this.#valList.fill(undefined)\n    this.#keyList.fill(undefined)\n    if (this.#ttls && this.#starts) {\n      this.#ttls.fill(0)\n      this.#starts.fill(0)\n    }\n    if (this.#sizes) {\n      this.#sizes.fill(0)\n    }\n    this.#head = 0 as Index\n    this.#tail = 0 as Index\n    this.#free.length = 0\n    this.#calculatedSize = 0\n    this.#size = 0\n    if (this.#hasDisposeAfter && this.#disposed) {\n      const dt = this.#disposed\n      let task: DisposeTask<K, V> | undefined\n      while ((task = dt?.shift())) {\n        this.#disposeAfter?.(...task)\n      }\n    }\n  }\n}\n", "/**\r\n * common.js\r\n */\r\n\r\n/* constants */\r\nconst TYPE_FROM = 8;\r\nconst TYPE_TO = -1;\r\n\r\n/**\r\n * get type\r\n * @param {*} o - object to check\r\n * @returns {string} - type of object\r\n */\r\nexport const getType = o =>\r\n  Object.prototype.toString.call(o).slice(TYPE_FROM, TYPE_TO);\r\n\r\n/**\r\n * is string\r\n * @param {*} o - object to check\r\n * @returns {boolean} - result\r\n */\r\nexport const isString = o => typeof o === 'string' || o instanceof String;\r\n", "/**\n * color.js\n *\n * Ref: CSS Color Module Level 4\n *      \u00A717. Sample code for Color Conversions\n *      https://w3c.github.io/csswg-drafts/css-color-4/#color-conversion-code\n */\n\nimport { getType, isString } from './common.js';\n\n/* constants */\nconst HALF = 0.5;\nconst DUO = 2;\nconst TRIA = 3;\nconst QUAT = 4;\nconst DEC = 10;\nconst HEX = 16;\nconst DEG = 360;\nconst DEG_INTERVAL = 60;\nconst MAX_PCT = 100;\nconst MAX_RGB = 255;\nconst POW_SQUARE = 2;\nconst POW_CUBE = 3;\nconst POW_LINEAR = 2.4;\nconst LINEAR_COEF = 12.92;\nconst LINEAR_OFFSET = 0.055;\nconst LAB_L = 116;\nconst LAB_A = 500;\nconst LAB_B = 200;\nconst LAB_EPSILON = 216 / 24389;\nconst LAB_KAPPA = 24389 / 27;\n\n/* white point */\nconst D50 = [0.3457 / 0.3585, 1, (1 - 0.3457 - 0.3585) / 0.3585];\nconst MATRIX_D50_TO_D65 = [\n  [0.9554734527042182, -0.023098536874261423, 0.0632593086610217],\n  [-0.028369706963208136, 1.0099954580058226, 0.021041398966943008],\n  [0.012314001688319899, -0.020507696433477912, 1.3303659366080753]\n];\nconst MATRIX_D65_TO_D50 = [\n  [1.0479298208405488, 0.022946793341019088, -0.05019222954313557],\n  [0.029627815688159344, 0.990434484573249, -0.01707382502938514],\n  [-0.009243058152591178, 0.015055144896577895, 0.7518742899580008]\n];\n\n/* color space */\nconst MATRIX_RGB_TO_XYZ = [\n  [506752 / 1228815, 87881 / 245763, 12673 / 70218],\n  [87098 / 409605, 175762 / 245763, 12673 / 175545],\n  [7918 / 409605, 87881 / 737289, 1001167 / 1053270]\n];\nconst MATRIX_XYZ_TO_RGB = [\n  [12831 / 3959, -329 / 214, -1974 / 3959],\n  [-851781 / 878810, 1648619 / 878810, 36519 / 878810],\n  [705 / 12673, -2585 / 12673, 705 / 667]\n];\nconst MATRIX_XYZ_TO_LMS = [\n  [0.8190224432164319, 0.3619062562801221, -0.12887378261216414],\n  [0.0329836671980271, 0.9292868468965546, 0.03614466816999844],\n  [0.048177199566046255, 0.26423952494422764, 0.6335478258136937]\n];\nconst MATRIX_LMS_TO_XYZ = [\n  [1.2268798733741557, -0.5578149965554813, 0.28139105017721583],\n  [-0.04057576262431372, 1.1122868293970594, -0.07171106666151701],\n  [-0.07637294974672142, -0.4214933239627914, 1.5869240244272418]\n];\nconst MATRIX_OKLAB_TO_LMS = [\n  [0.9999999984505196, 0.39633779217376774, 0.2158037580607588],\n  [1.0000000088817607, -0.10556134232365633, -0.0638541747717059],\n  [1.0000000546724108, -0.08948418209496574, -1.2914855378640917]\n];\nconst MATRIX_LMS_TO_OKLAB = [\n  [0.2104542553, 0.7936177850, -0.0040720468],\n  [1.9779984951, -2.4285922050, 0.4505937099],\n  [0.0259040371, 0.7827717662, -0.8086757660]\n];\nconst MATRIX_P3_TO_XYZ = [\n  [608311 / 1250200, 189793 / 714400, 198249 / 1000160],\n  [35783 / 156275, 247089 / 357200, 198249 / 2500400],\n  [0, 32229 / 714400, 5220557 / 5000800]\n];\nconst MATRIX_REC2020_TO_XYZ = [\n  [63426534 / 99577255, 20160776 / 139408157, 47086771 / 278816314],\n  [26158966 / 99577255, 472592308 / 697040785, 8267143 / 139408157],\n  [0, 19567812 / 697040785, 295819943 / 278816314]\n];\nconst MATRIX_A98_TO_XYZ = [\n  [573536 / 994567, 263643 / 1420810, 187206 / 994567],\n  [591459 / 1989134, 6239551 / 9945670, 374412 / 4972835],\n  [53769 / 1989134, 351524 / 4972835, 4929758 / 4972835]\n];\nconst MATRIX_PROPHOTO_TO_XYZ_D50 = [\n  [0.7977604896723027, 0.13518583717574031, 0.0313493495815248],\n  [0.2880711282292934, 0.7118432178101014, 0.00008565396060525902],\n  [0, 0, 0.8251046025104601]\n];\n\n/* regexp */\nconst NONE = 'none';\nconst REG_ANGLE = 'deg|g?rad|turn';\nconst REG_SRGB = 'srgb(?:-linear)?';\nconst REG_COLOR_SPACE_XYZ = 'xyz(?:-d(?:50|65))?';\nconst REG_COLOR_SPACE_COLOR_MIX =\n  `(?:ok)?l(?:ab|ch)|h(?:sl|wb)|${REG_SRGB}|${REG_COLOR_SPACE_XYZ}`;\nconst REG_COLOR_SPACE_RGB =\n  `(?:a98|prophoto)-rgb|display-p3|rec2020|${REG_SRGB}`;\nconst REG_NUM =\n  '[+-]?(?:(?:0|[1-9]\\\\d*)(?:\\\\.\\\\d*)?|\\\\.\\\\d+)(?:e-?(?:0|[1-9]\\\\d*))?';\nconst REG_PCT = `${REG_NUM}%`;\nconst REG_HSL = `(?:${REG_NUM}(?:${REG_ANGLE})?|${NONE})(?:\\\\s+(?:${REG_PCT}|${NONE})){2}(?:\\\\s*\\\\/\\\\s*(?:${REG_NUM}|${REG_PCT}|${NONE}))?`;\nconst REG_HSL_LV3 = `${REG_NUM}(?:${REG_ANGLE})?(?:\\\\s*,\\\\s*${REG_PCT}){2}(?:\\\\s*,\\\\s*(?:${REG_NUM}|${REG_PCT}))?`;\nconst REG_RGB = `(?:(?:${REG_NUM}|${NONE})(?:\\\\s+(?:${REG_NUM}|${NONE})){2}|(?:${REG_PCT}|${NONE})(?:\\\\s+(?:${REG_PCT}|${NONE})){2})(?:\\\\s*\\\\/\\\\s*(?:${REG_NUM}|${REG_PCT}|${NONE}))?`;\nconst REG_RGB_LV3 = `(?:${REG_NUM}(?:\\\\s*,\\\\s*${REG_NUM}){2}|${REG_PCT}(?:\\\\s*,\\\\s*${REG_PCT}){2})(?:\\\\s*,\\\\s*(?:${REG_NUM}|${REG_PCT}))?`;\nconst REG_LAB = `(?:${REG_NUM}|${REG_PCT}|${NONE})(?:\\\\s+(?:${REG_NUM}|${REG_PCT}|${NONE})){2}(?:\\\\s*\\\\/\\\\s*(?:${REG_NUM}|${REG_PCT}|${NONE}))?`;\nconst REG_LCH = `(?:(?:${REG_NUM}|${REG_PCT}|${NONE})\\\\s+){2}(?:${REG_NUM}(?:${REG_ANGLE})?|${NONE})(?:\\\\s*\\\\/\\\\s*(?:${REG_NUM}|${REG_PCT}|${NONE}))?`;\nconst REG_COLOR_FUNC = `(?:${REG_COLOR_SPACE_RGB}|${REG_COLOR_SPACE_XYZ})(?:\\\\s+(?:${REG_NUM}|${REG_PCT}|${NONE})){3}(?:\\\\s*\\\\/\\\\s*(?:${REG_NUM}|${REG_PCT}|${NONE}))?`;\nconst REG_COLOR_TYPE = `[a-z]+|#(?:[\\\\da-f]{3}|[\\\\da-f]{4}|[\\\\da-f]{6}|[\\\\da-f]{8})|hsla?\\\\(\\\\s*(?:${REG_HSL}|${REG_HSL_LV3})\\\\s*\\\\)|hwb\\\\(\\\\s*${REG_HSL}\\\\s*\\\\)|rgba?\\\\(\\\\s*(?:${REG_RGB}|${REG_RGB_LV3})\\\\s*\\\\)|(?:ok)?lab\\\\(\\\\s*${REG_LAB}\\\\s*\\\\)|(?:ok)?lch\\\\(\\\\s*${REG_LCH}\\\\s*\\\\)|color\\\\(\\\\s*${REG_COLOR_FUNC}\\\\s*\\\\)`;\nconst REG_COLOR_MIX_PART = `(?:${REG_COLOR_TYPE})(?:\\\\s+${REG_PCT})?`;\nconst REG_COLOR_MIX_CAPT = `color-mix\\\\(\\\\s*in\\\\s+(${REG_COLOR_SPACE_COLOR_MIX})\\\\s*,\\\\s*(${REG_COLOR_MIX_PART})\\\\s*,\\\\s*(${REG_COLOR_MIX_PART})\\\\s*\\\\)`;\nconst REG_CURRENT_COLOR = /^currentColor$/i;\n\n/* named colors */\nconst NAMED_COLORS = {\n  aliceblue: [0xF0, 0xF8, 0xFF],\n  antiquewhite: [0xFA, 0xEB, 0xD7],\n  aqua: [0x00, 0xFF, 0xFF],\n  aquamarine: [0x7F, 0xFF, 0xD4],\n  azure: [0xF0, 0xFF, 0xFF],\n  beige: [0xF5, 0xF5, 0xDC],\n  bisque: [0xFF, 0xE4, 0xC4],\n  black: [0x00, 0x00, 0x00],\n  blanchedalmond: [0xFF, 0xEB, 0xCD],\n  blue: [0x00, 0x00, 0xFF],\n  blueviolet: [0x8A, 0x2B, 0xE2],\n  brown: [0xA5, 0x2A, 0x2A],\n  burlywood: [0xDE, 0xB8, 0x87],\n  cadetblue: [0x5F, 0x9E, 0xA0],\n  chartreuse: [0x7F, 0xFF, 0x00],\n  chocolate: [0xD2, 0x69, 0x1E],\n  coral: [0xFF, 0x7F, 0x50],\n  cornflowerblue: [0x64, 0x95, 0xED],\n  cornsilk: [0xFF, 0xF8, 0xDC],\n  crimson: [0xDC, 0x14, 0x3C],\n  cyan: [0x00, 0xFF, 0xFF],\n  darkblue: [0x00, 0x00, 0x8B],\n  darkcyan: [0x00, 0x8B, 0x8B],\n  darkgoldenrod: [0xB8, 0x86, 0x0B],\n  darkgray: [0xA9, 0xA9, 0xA9],\n  darkgreen: [0x00, 0x64, 0x00],\n  darkgrey: [0xA9, 0xA9, 0xA9],\n  darkkhaki: [0xBD, 0xB7, 0x6B],\n  darkmagenta: [0x8B, 0x00, 0x8B],\n  darkolivegreen: [0x55, 0x6B, 0x2F],\n  darkorange: [0xFF, 0x8C, 0x00],\n  darkorchid: [0x99, 0x32, 0xCC],\n  darkred: [0x8B, 0x00, 0x00],\n  darksalmon: [0xE9, 0x96, 0x7A],\n  darkseagreen: [0x8F, 0xBC, 0x8F],\n  darkslateblue: [0x48, 0x3D, 0x8B],\n  darkslategray: [0x2F, 0x4F, 0x4F],\n  darkslategrey: [0x2F, 0x4F, 0x4F],\n  darkturquoise: [0x00, 0xCE, 0xD1],\n  darkviolet: [0x94, 0x00, 0xD3],\n  deeppink: [0xFF, 0x14, 0x93],\n  deepskyblue: [0x00, 0xBF, 0xFF],\n  dimgray: [0x69, 0x69, 0x69],\n  dimgrey: [0x69, 0x69, 0x69],\n  dodgerblue: [0x1E, 0x90, 0xFF],\n  firebrick: [0xB2, 0x22, 0x22],\n  floralwhite: [0xFF, 0xFA, 0xF0],\n  forestgreen: [0x22, 0x8B, 0x22],\n  fuchsia: [0xFF, 0x00, 0xFF],\n  gainsboro: [0xDC, 0xDC, 0xDC],\n  ghostwhite: [0xF8, 0xF8, 0xFF],\n  gold: [0xFF, 0xD7, 0x00],\n  goldenrod: [0xDA, 0xA5, 0x20],\n  gray: [0x80, 0x80, 0x80],\n  green: [0x00, 0x80, 0x00],\n  greenyellow: [0xAD, 0xFF, 0x2F],\n  grey: [0x80, 0x80, 0x80],\n  honeydew: [0xF0, 0xFF, 0xF0],\n  hotpink: [0xFF, 0x69, 0xB4],\n  indianred: [0xCD, 0x5C, 0x5C],\n  indigo: [0x4B, 0x00, 0x82],\n  ivory: [0xFF, 0xFF, 0xF0],\n  khaki: [0xF0, 0xE6, 0x8C],\n  lavender: [0xE6, 0xE6, 0xFA],\n  lavenderblush: [0xFF, 0xF0, 0xF5],\n  lawngreen: [0x7C, 0xFC, 0x00],\n  lemonchiffon: [0xFF, 0xFA, 0xCD],\n  lightblue: [0xAD, 0xD8, 0xE6],\n  lightcoral: [0xF0, 0x80, 0x80],\n  lightcyan: [0xE0, 0xFF, 0xFF],\n  lightgoldenrodyellow: [0xFA, 0xFA, 0xD2],\n  lightgray: [0xD3, 0xD3, 0xD3],\n  lightgreen: [0x90, 0xEE, 0x90],\n  lightgrey: [0xD3, 0xD3, 0xD3],\n  lightpink: [0xFF, 0xB6, 0xC1],\n  lightsalmon: [0xFF, 0xA0, 0x7A],\n  lightseagreen: [0x20, 0xB2, 0xAA],\n  lightskyblue: [0x87, 0xCE, 0xFA],\n  lightslategray: [0x77, 0x88, 0x99],\n  lightslategrey: [0x77, 0x88, 0x99],\n  lightsteelblue: [0xB0, 0xC4, 0xDE],\n  lightyellow: [0xFF, 0xFF, 0xE0],\n  lime: [0x00, 0xFF, 0x00],\n  limegreen: [0x32, 0xCD, 0x32],\n  linen: [0xFA, 0xF0, 0xE6],\n  magenta: [0xFF, 0x00, 0xFF],\n  maroon: [0x80, 0x00, 0x00],\n  mediumaquamarine: [0x66, 0xCD, 0xAA],\n  mediumblue: [0x00, 0x00, 0xCD],\n  mediumorchid: [0xBA, 0x55, 0xD3],\n  mediumpurple: [0x93, 0x70, 0xDB],\n  mediumseagreen: [0x3C, 0xB3, 0x71],\n  mediumslateblue: [0x7B, 0x68, 0xEE],\n  mediumspringgreen: [0x00, 0xFA, 0x9A],\n  mediumturquoise: [0x48, 0xD1, 0xCC],\n  mediumvioletred: [0xC7, 0x15, 0x85],\n  midnightblue: [0x19, 0x19, 0x70],\n  mintcream: [0xF5, 0xFF, 0xFA],\n  mistyrose: [0xFF, 0xE4, 0xE1],\n  moccasin: [0xFF, 0xE4, 0xB5],\n  navajowhite: [0xFF, 0xDE, 0xAD],\n  navy: [0x00, 0x00, 0x80],\n  oldlace: [0xFD, 0xF5, 0xE6],\n  olive: [0x80, 0x80, 0x00],\n  olivedrab: [0x6B, 0x8E, 0x23],\n  orange: [0xFF, 0xA5, 0x00],\n  orangered: [0xFF, 0x45, 0x00],\n  orchid: [0xDA, 0x70, 0xD6],\n  palegoldenrod: [0xEE, 0xE8, 0xAA],\n  palegreen: [0x98, 0xFB, 0x98],\n  paleturquoise: [0xAF, 0xEE, 0xEE],\n  palevioletred: [0xDB, 0x70, 0x93],\n  papayawhip: [0xFF, 0xEF, 0xD5],\n  peachpuff: [0xFF, 0xDA, 0xB9],\n  peru: [0xCD, 0x85, 0x3F],\n  pink: [0xFF, 0xC0, 0xCB],\n  plum: [0xDD, 0xA0, 0xDD],\n  powderblue: [0xB0, 0xE0, 0xE6],\n  purple: [0x80, 0x00, 0x80],\n  rebeccapurple: [0x66, 0x33, 0x99],\n  red: [0xFF, 0x00, 0x00],\n  rosybrown: [0xBC, 0x8F, 0x8F],\n  royalblue: [0x41, 0x69, 0xE1],\n  saddlebrown: [0x8B, 0x45, 0x13],\n  salmon: [0xFA, 0x80, 0x72],\n  sandybrown: [0xF4, 0xA4, 0x60],\n  seagreen: [0x2E, 0x8B, 0x57],\n  seashell: [0xFF, 0xF5, 0xEE],\n  sienna: [0xA0, 0x52, 0x2D],\n  silver: [0xC0, 0xC0, 0xC0],\n  skyblue: [0x87, 0xCE, 0xEB],\n  slateblue: [0x6A, 0x5A, 0xCD],\n  slategray: [0x70, 0x80, 0x90],\n  slategrey: [0x70, 0x80, 0x90],\n  snow: [0xFF, 0xFA, 0xFA],\n  springgreen: [0x00, 0xFF, 0x7F],\n  steelblue: [0x46, 0x82, 0xB4],\n  tan: [0xD2, 0xB4, 0x8C],\n  teal: [0x00, 0x80, 0x80],\n  thistle: [0xD8, 0xBF, 0xD8],\n  tomato: [0xFF, 0x63, 0x47],\n  turquoise: [0x40, 0xE0, 0xD0],\n  violet: [0xEE, 0x82, 0xEE],\n  wheat: [0xF5, 0xDE, 0xB3],\n  white: [0xFF, 0xFF, 0xFF],\n  whitesmoke: [0xF5, 0xF5, 0xF5],\n  yellow: [0xFF, 0xFF, 0x00],\n  yellowgreen: [0x9A, 0xCD, 0x32]\n};\n\n/**\n * validate color components\n * @param {Array} arr - array of color components\n * @param {object} [opt] - options\n * @param {boolean} [opt.alpha] - alpha\n * @param {number} [opt.minLength] - min length\n * @param {number} [opt.maxLength] - max length\n * @param {number} [opt.minRange] - min range\n * @param {number} [opt.maxRange] - max range\n * @param {boolean} [opt.validateRange] - validate range\n * @returns {Array} - arr;\n */\nexport const validateColorComponents = (arr, opt = {}) => {\n  if (!Array.isArray(arr)) {\n    throw new TypeError(`Expected Array but got ${getType(arr)}.`);\n  }\n  const {\n    alpha = false,\n    minLength = TRIA,\n    maxLength = QUAT,\n    minRange = 0,\n    maxRange = 1,\n    validateRange = true\n  } = opt;\n  if (typeof minLength !== 'number') {\n    throw new TypeError(`Expected Number but got ${getType(minLength)}.`);\n  } else if (Number.isNaN(minLength)) {\n    throw new TypeError(`${minLength} is not a number.`);\n  }\n  if (typeof maxLength !== 'number') {\n    throw new TypeError(`Expected Number but got ${getType(maxLength)}.`);\n  } else if (Number.isNaN(maxLength)) {\n    throw new TypeError(`${maxLength} is not a number.`);\n  }\n  if (typeof minRange !== 'number') {\n    throw new TypeError(`Expected Number but got ${getType(minRange)}.`);\n  } else if (Number.isNaN(minRange)) {\n    throw new TypeError(`${minRange} is not a number.`);\n  }\n  if (typeof maxRange !== 'number') {\n    throw new TypeError(`Expected Number but got ${getType(maxRange)}.`);\n  } else if (Number.isNaN(maxRange)) {\n    throw new TypeError(`${maxRange} is not a number.`);\n  }\n  const l = arr.length;\n  if (l < minLength || l > maxLength) {\n    let msg;\n    if (minLength === maxLength) {\n      msg = `Expected array length of ${maxLength} but got ${l}.`;\n    } else {\n      msg =\n        `Expected array length of ${minLength} or ${maxLength} but got ${l}.`;\n    }\n    throw new Error(msg);\n  }\n  let i = 0;\n  while (i < l) {\n    const v = arr[i];\n    if (typeof v !== 'number') {\n      throw new TypeError(`Expected Number but got ${getType(v)}.`);\n    } else if (Number.isNaN(v)) {\n      throw new TypeError(`${v} is not a number.`);\n    } else if (i < TRIA && validateRange && (v < minRange || v > maxRange)) {\n      throw new RangeError(`${v} is not between ${minRange} and ${maxRange}.`);\n    } else if (i === TRIA && (v < 0 || v > 1)) {\n      throw new RangeError(`${v} is not between 0 and 1.`);\n    }\n    i++;\n  }\n  if (alpha && l === TRIA) {\n    arr.push(1);\n  }\n  return arr;\n};\n\n/**\n * transform matrix\n * @param {Array.<Array.<number>>} mtx - 3 * 3 matrix\n * @param {Array.<number>} vct - vector\n * @returns {Array.<number>} - [p1, p2, p3]\n */\nexport const transformMatrix = (mtx, vct) => {\n  if (!Array.isArray(mtx)) {\n    throw new TypeError(`Expected Array but got ${getType(mtx)}.`);\n  } else if (mtx.length !== TRIA) {\n    throw new Error(`Expected array length of 3 but got ${mtx.length}.`);\n  } else {\n    for (let i of mtx) {\n      i = validateColorComponents(i, {\n        maxLength: TRIA,\n        validateRange: false\n      });\n    }\n  }\n  const [\n    [r1c1, r1c2, r1c3],\n    [r2c1, r2c2, r2c3],\n    [r3c1, r3c2, r3c3]\n  ] = mtx;\n  const [v1, v2, v3] = validateColorComponents(vct, {\n    maxLength: TRIA,\n    validateRange: false\n  });\n  const p1 = r1c1 * v1 + r1c2 * v2 + r1c3 * v3;\n  const p2 = r2c1 * v1 + r2c2 * v2 + r2c3 * v3;\n  const p3 = r3c1 * v1 + r3c2 * v2 + r3c3 * v3;\n  return [p1, p2, p3];\n};\n\n/**\n * re-insert missing color components\n * @param {string} value - value\n * @param {Array} color - array of color components [r, g, b, a]|[l, c, h, a]\n * @returns {Array<number|string>} - [v1, v2, v3, v4]\n */\nexport const reInsertMissingColorComponents = (value, color = []) => {\n  if (isString(value)) {\n    value = value.trim();\n  } else {\n    throw new TypeError(`Expected String but got ${getType(value)}.`);\n  }\n  const [v1, v2, v3, v4] = color;\n  let v1m, v2m, v3m, v4m;\n  if (/none/.test(value)) {\n    const regRgb = new RegExp(`^rgba?\\\\(\\\\s*(${REG_RGB})\\\\s*\\\\)$`);\n    const regColor = new RegExp(`^color\\\\(\\\\s*(${REG_COLOR_FUNC})\\\\s*\\\\)$`);\n    const regHsl = new RegExp(`^h(?:sla?|wb)\\\\(\\\\s*(${REG_HSL})\\\\s*\\\\)$`);\n    const regLab = new RegExp(`^(?:ok)?lab\\\\(\\\\s*(${REG_LAB})\\\\s*\\\\)$`);\n    const regLch = new RegExp(`^(?:ok)?lch\\\\(\\\\s*(${REG_LCH})\\\\s*\\\\)$`);\n    // rgb()\n    if (regRgb.test(value)) {\n      [v1m, v2m, v3m, v4m] =\n        value.match(regRgb)[1].replace('/', ' ').split(/\\s+/);\n    // color()\n    } else if (regColor.test(value)) {\n      [, v1m, v2m, v3m, v4m] =\n        value.match(regColor)[1].replace('/', ' ').split(/\\s+/);\n    // hsl()\n    } else if (value.startsWith('hsl') && regHsl.test(value)) {\n      [v3m, v2m, v1m, v4m] =\n        value.match(regHsl)[1].replace('/', ' ').split(/\\s+/);\n    // hwb()\n    } else if (value.startsWith('hwb') && regHsl.test(value)) {\n      [v3m, , , v4m] = value.match(regHsl)[1].replace('/', ' ').split(/\\s+/);\n    // lab(), oklab()\n    } else if (regLab.test(value)) {\n      [v1m, , , v4m] = value.match(regLab)[1].replace('/', ' ').split(/\\s+/);\n    // lch(), oklch()\n    } else if (regLch.test(value)) {\n      [v1m, v2m, v3m, v4m] =\n        value.match(regLch)[1].replace('/', ' ').split(/\\s+/);\n    }\n  }\n  return [\n    v1m === NONE ? v1m : v1,\n    v2m === NONE ? v2m : v2,\n    v3m === NONE ? v3m : v3,\n    v4m === NONE ? v4m : v4\n  ];\n};\n\n/**\n * normalize color components\n * @param {Array} colorA - array of color components [v1, v2, v3, v4]\n * @param {Array} colorB - array of color components [v1, v2, v3, v4]\n * @returns {Array.<Array.<number>>} - [colorA, colorB]\n */\nexport const normalizeColorComponents = (colorA, colorB) => {\n  if (!Array.isArray(colorA)) {\n    throw new TypeError(`Expected Array but got ${getType(colorA)}.`);\n  } else if (colorA.length !== QUAT) {\n    throw new Error(`Expected array length of 4 but got ${colorA.length}.`);\n  }\n  if (!Array.isArray(colorB)) {\n    throw new TypeError(`Expected Array but got ${getType(colorB)}.`);\n  } else if (colorB.length !== QUAT) {\n    throw new Error(`Expected array length of 4 but got ${colorB.length}.`);\n  }\n  let i = 0;\n  while (i < QUAT) {\n    if (colorA[i] === NONE && colorB[i] === NONE) {\n      colorA[i] = 0;\n      colorB[i] = 0;\n    } else if (colorA[i] === NONE) {\n      colorA[i] = colorB[i];\n    } else if (colorB[i] === NONE) {\n      colorB[i] = colorA[i];\n    }\n    i++;\n  }\n  colorA = validateColorComponents(colorA, {\n    minLength: QUAT,\n    validateRange: false\n  });\n  colorB = validateColorComponents(colorB, {\n    minLength: QUAT,\n    validateRange: false\n  });\n  return [colorA, colorB];\n};\n\n/**\n * number to hex string\n * @param {number} value - color value\n * @returns {string} - hex string\n */\nexport const numberToHexString = value => {\n  if (typeof value !== 'number') {\n    throw new TypeError(`Expected Number but got ${getType(value)}.`);\n  } else if (Number.isNaN(value)) {\n    throw new TypeError(`${value} is not a number.`);\n  } else {\n    value = Math.round(value);\n    if (value < 0 || value > MAX_RGB) {\n      throw new RangeError(`${value} is not between 0 and ${MAX_RGB}.`);\n    }\n  }\n  let hex = value.toString(HEX);\n  if (hex.length === 1) {\n    hex = `0${hex}`;\n  }\n  return hex;\n};\n\n/**\n * angle to deg\n * @param {string} angle - angle\n * @returns {number} - deg 0..360\n */\nexport const angleToDeg = angle => {\n  if (isString(angle)) {\n    angle = angle.trim();\n  } else {\n    throw new TypeError(`Expected String but got ${getType(angle)}.`);\n  }\n  const GRAD = DEG / 400;\n  const RAD = DEG / (Math.PI * DUO);\n  const reg = new RegExp(`^(${REG_NUM})(${REG_ANGLE})?$`);\n  if (!reg.test(angle)) {\n    throw new Error(`Invalid property value: ${angle}`);\n  }\n  const [, val, unit] = angle.match(reg);\n  const value = val.startsWith('.') ? `0${val}` : val;\n  let deg;\n  switch (unit) {\n    case 'grad':\n      deg = parseFloat(value) * GRAD;\n      break;\n    case 'rad':\n      deg = parseFloat(value) * RAD;\n      break;\n    case 'turn':\n      deg = parseFloat(value) * DEG;\n      break;\n    default:\n      deg = parseFloat(value);\n  }\n  deg %= DEG;\n  if (deg < 0) {\n    deg += DEG;\n  } else if (Object.is(deg, -0)) {\n    deg = 0;\n  }\n  return deg;\n};\n\n/**\n * convert rgb to linear rgb\n * @param {Array.<number>} rgb - [r, g, b] r|g|b: 0..255\n * @returns {Array.<number>} - [r, g, b] r|g|b: 0..1\n */\nexport const convertRgbToLinearRgb = rgb => {\n  const [rr, gg, bb] = validateColorComponents(rgb, {\n    maxLength: TRIA,\n    maxRange: MAX_RGB\n  });\n  let r = rr / MAX_RGB;\n  let g = gg / MAX_RGB;\n  let b = bb / MAX_RGB;\n  const COND_POW = 0.04045;\n  if (r > COND_POW) {\n    r = Math.pow((r + LINEAR_OFFSET) / (1 + LINEAR_OFFSET), POW_LINEAR);\n  } else {\n    r /= LINEAR_COEF;\n  }\n  if (g > COND_POW) {\n    g = Math.pow((g + LINEAR_OFFSET) / (1 + LINEAR_OFFSET), POW_LINEAR);\n  } else {\n    g /= LINEAR_COEF;\n  }\n  if (b > COND_POW) {\n    b = Math.pow((b + LINEAR_OFFSET) / (1 + LINEAR_OFFSET), POW_LINEAR);\n  } else {\n    b /= LINEAR_COEF;\n  }\n  return [r, g, b];\n};\n\n/**\n * convert rgb to xyz\n * @param {Array.<number>} rgb - [r, g, b, [a]] r|g|b: 0..255 a: 0..1\n * @returns {Array.<number>} - [x, y, z, a] x|y|z|a: 0..1\n */\nexport const convertRgbToXyz = rgb => {\n  const [r, g, b, a] = validateColorComponents(rgb, {\n    alpha: true,\n    maxRange: MAX_RGB\n  });\n  const [rr, gg, bb] = convertRgbToLinearRgb([r, g, b]);\n  const [x, y, z] = transformMatrix(MATRIX_RGB_TO_XYZ, [rr, gg, bb]);\n  return [x, y, z, a];\n};\n\n/**\n * convert rgb to xyz-d50\n * @param {Array.<number>} rgb - [r, g, b, [a]] r|g|b: 0..255 a: 0..1\n * @returns {Array.<number>} - [x, y, z, a] x|y|z|a: 0..1\n */\nexport const convertRgbToXyzD50 = rgb => {\n  const [xx, yy, zz, a] = convertRgbToXyz(rgb);\n  const [x, y, z] = transformMatrix(MATRIX_D65_TO_D50, [xx, yy, zz]);\n  return [x, y, z, a];\n};\n\n/**\n * convert rgb to hex color\n * @param {Array.<number>} rgb - [r, g, b, a] r|g|b: 0..255 a: 0..1\n * @returns {string} - hex color;\n */\nexport const convertRgbToHex = rgb => {\n  const [r, g, b, a] = validateColorComponents(rgb, {\n    alpha: true,\n    maxRange: MAX_RGB\n  });\n  const rr = numberToHexString(r);\n  const gg = numberToHexString(g);\n  const bb = numberToHexString(b);\n  const aa = numberToHexString(a * MAX_RGB);\n  let hex;\n  if (aa === 'ff') {\n    hex = `#${rr}${gg}${bb}`;\n  } else {\n    hex = `#${rr}${gg}${bb}${aa}`;\n  }\n  return hex;\n};\n\n/**\n * convert linear rgb to rgb\n * @param {Array.<number>} rgb - [r, g, b] r|g|b: 0..1\n * @returns {Array.<number>} - [r, g, b] r|g|b: 0..255\n */\nexport const convertLinearRgbToRgb = rgb => {\n  let [r, g, b] = validateColorComponents(rgb, {\n    maxLength: TRIA\n  });\n  const COND_POW = 809 / 258400;\n  if (r > COND_POW) {\n    r = Math.pow(r, 1 / POW_LINEAR) * (1 + LINEAR_OFFSET) - LINEAR_OFFSET;\n  } else {\n    r *= LINEAR_COEF;\n  }\n  if (g > COND_POW) {\n    g = Math.pow(g, 1 / POW_LINEAR) * (1 + LINEAR_OFFSET) - LINEAR_OFFSET;\n  } else {\n    g *= LINEAR_COEF;\n  }\n  if (b > COND_POW) {\n    b = Math.pow(b, 1 / POW_LINEAR) * (1 + LINEAR_OFFSET) - LINEAR_OFFSET;\n  } else {\n    b *= LINEAR_COEF;\n  }\n  return [\n    Math.round(r * MAX_RGB),\n    Math.round(g * MAX_RGB),\n    Math.round(b * MAX_RGB)\n  ];\n};\n\n/**\n * convert linear rgb to hex color\n * @param {Array.<number>} rgb - [r, g, b, a] r|g|b|a: 0..1\n * @returns {string} - hex color\n */\nexport const convertLinearRgbToHex = rgb => {\n  let [r, g, b, a] = validateColorComponents(rgb, {\n    minLength: QUAT\n  });\n  [r, g, b] = convertLinearRgbToRgb([r, g, b]);\n  const rr = numberToHexString(r);\n  const gg = numberToHexString(g);\n  const bb = numberToHexString(b);\n  const aa = numberToHexString(a * MAX_RGB);\n  let hex;\n  if (aa === 'ff') {\n    hex = `#${rr}${gg}${bb}`;\n  } else {\n    hex = `#${rr}${gg}${bb}${aa}`;\n  }\n  return hex;\n};\n\n/**\n * convert xyz to hex color\n * @param {Array.<number>} xyz - [x, y, z, a] x|y|z|a: 0..1\n * @returns {string} - hex color\n */\nexport const convertXyzToHex = xyz => {\n  const [x, y, z, a] = validateColorComponents(xyz, {\n    minLength: QUAT,\n    validateRange: false\n  });\n  const [r, g, b] = transformMatrix(MATRIX_XYZ_TO_RGB, [x, y, z]);\n  const hex = convertLinearRgbToHex([\n    Math.min(Math.max(r, 0), 1),\n    Math.min(Math.max(g, 0), 1),\n    Math.min(Math.max(b, 0), 1),\n    a\n  ]);\n  return hex;\n};\n\n/**\n * convert xyz D50 to hex color\n * @param {Array.<number>} xyz - [x, y, z, a] x|y|z|a: 0..1\n * @returns {string} - hex color\n */\nexport const convertXyzD50ToHex = xyz => {\n  const [x, y, z, a] = validateColorComponents(xyz, {\n    minLength: QUAT,\n    validateRange: false\n  });\n  const xyzD65 = transformMatrix(MATRIX_D50_TO_D65, [x, y, z]);\n  const [r, g, b] = transformMatrix(MATRIX_XYZ_TO_RGB, xyzD65);\n  const hex = convertLinearRgbToHex([\n    Math.min(Math.max(r, 0), 1),\n    Math.min(Math.max(g, 0), 1),\n    Math.min(Math.max(b, 0), 1),\n    a\n  ]);\n  return hex;\n};\n\n/**\n * convert xyz to rgb\n * @param {Array.<number>} xyz - [x, y, z, a] x|y|z|a: 0..1\n * @returns {Array.<number>} - [r, g, b, a] r|g|b: 0..255 a: 0..1\n */\nexport const convertXyzToRgb = xyz => {\n  const [x, y, z, a] = validateColorComponents(xyz, {\n    validateRange: false\n  });\n  let [r, g, b] = transformMatrix(MATRIX_XYZ_TO_RGB, [x, y, z]);\n  [r, g, b] = convertLinearRgbToRgb([\n    Math.min(Math.max(r, 0), 1),\n    Math.min(Math.max(g, 0), 1),\n    Math.min(Math.max(b, 0), 1)\n  ]);\n  return [r, g, b, a];\n};\n\n/**\n * convert xyz to xyz-d50\n * @param {Array.<number>} xyz - [x, y, z, a] x|y|z|a: 0..1\n * @returns {Array.<number>} xyz - [x, y, z, a] x|y|z|a: 0..1\n */\nexport const convertXyzToXyzD50 = xyz => {\n  const [xx, yy, zz, a] = validateColorComponents(xyz, {\n    validateRange: false\n  });\n  const [x, y, z] = transformMatrix(MATRIX_D65_TO_D50, [xx, yy, zz]);\n  return [x, y, z, a];\n};\n\n/**\n * convert xyz to hsl\n * @param {Array.<number>} xyz - [x, y, z, a] x|y|z|a: 0..1\n * @returns {Array.<number>} - [h, s, l, a] h: 0..360 s|l: 0..100 a: 0..1\n */\nexport const convertXyzToHsl = xyz => {\n  const [rr, gg, bb, a] = convertXyzToRgb(xyz);\n  const r = rr / MAX_RGB;\n  const g = gg / MAX_RGB;\n  const b = bb / MAX_RGB;\n  const max = Math.max(r, g, b);\n  const min = Math.min(r, g, b);\n  const d = max - min;\n  const l = (max + min) * HALF * MAX_PCT;\n  let h, s;\n  if (Math.round(l) === 0 || Math.round(l) === MAX_PCT) {\n    h = NONE;\n    s = NONE;\n  } else {\n    s = d / (1 - Math.abs(max + min - 1)) * MAX_PCT;\n    if (s === 0) {\n      h = NONE;\n    } else {\n      switch (max) {\n        case r:\n          h = (g - b) / d;\n          break;\n        case g:\n          h = (b - r) / d + DUO;\n          break;\n        case b:\n        default:\n          h = (r - g) / d + QUAT;\n          break;\n      }\n      h = h * DEG_INTERVAL % DEG;\n      if (h < 0) {\n        h += DEG;\n      }\n    }\n  }\n  return [h, s, l, a];\n};\n\n/**\n * convert xyz to hwb\n * @param {Array.<number>} xyz - [x, y, z, a] x|y|z|a: 0..1\n * @returns {Array.<number>} - [h, w, b, a] h: 0..360 w|b: 0..100 a: 0..1\n */\nexport const convertXyzToHwb = xyz => {\n  const [r, g, b, a] = convertXyzToRgb(xyz);\n  const w = Math.min(r, g, b) / MAX_RGB;\n  const bk = 1 - Math.max(r, g, b) / MAX_RGB;\n  let h;\n  if (w + bk === 1) {\n    h = NONE;\n  } else {\n    [h] = convertXyzToHsl(xyz);\n  }\n  return [\n    h,\n    w * MAX_PCT,\n    bk * MAX_PCT,\n    a\n  ];\n};\n\n/**\n * convert xyz to oklab\n * @param {Array.<number>} xyz - [x, y, z, a] x|y|z|a: 0..1\n * @returns {Array.<number>} - [l, a, b, aa] l|aa: 0..1 a|b: -0.4..0.4\n */\nexport const convertXyzToOklab = xyz => {\n  const [x, y, z, aa] = validateColorComponents(xyz, {\n    validateRange: false\n  });\n  const lms = transformMatrix(MATRIX_XYZ_TO_LMS, [x, y, z]);\n  const xyzLms = lms.map(c => Math.cbrt(c));\n  let [l, a, b] = transformMatrix(MATRIX_LMS_TO_OKLAB, xyzLms);\n  l = Math.min(Math.max(l, 0), 1);\n  const lPct = Math.round(parseFloat(l.toFixed(QUAT)) * MAX_PCT);\n  if (lPct === 0 || lPct === MAX_PCT) {\n    a = NONE;\n    b = NONE;\n  }\n  return [l, a, b, aa];\n};\n\n/**\n * convert xyz to oklch\n * @param {Array.<number>} xyz - [x, y, z, a] x|y|z|a: 0..1\n * @returns {Array.<number>} - [l, c, h, aa] l|aa: 0..1 c: 0..0.4 h: 0..360\n */\nexport const convertXyzToOklch = xyz => {\n  const [l, a, b, aa] = convertXyzToOklab(xyz);\n  let c, h;\n  const lPct = Math.round(parseFloat(l.toFixed(QUAT)) * MAX_PCT);\n  if (lPct === 0 || lPct === MAX_PCT) {\n    c = NONE;\n    h = NONE;\n  } else {\n    c =\n      Math.max(Math.sqrt(Math.pow(a, POW_SQUARE) + Math.pow(b, POW_SQUARE)), 0);\n    if (parseFloat(c.toFixed(QUAT)) === 0) {\n      h = NONE;\n    } else {\n      h = Math.atan2(b, a) * DEG * HALF / Math.PI;\n      if (h < 0) {\n        h += DEG;\n      }\n    }\n  }\n  return [l, c, h, aa];\n};\n\n/**\n * convert xyz D50 to rgb\n * @param {Array.<number>} xyz - [x, y, z, a] x|y|z|a: 0..1\n * @returns {Array.<number>} - [r, g, b, a] r|g|b: 0..255 a: 0..1\n */\nexport const convertXyzD50ToRgb = xyz => {\n  const [x, y, z, a] = validateColorComponents(xyz, {\n    minLength: QUAT,\n    validateRange: false\n  });\n  const xyzD65 = transformMatrix(MATRIX_D50_TO_D65, [x, y, z]);\n  const [r, g, b] = convertXyzToRgb(xyzD65);\n  return [r, g, b, a];\n};\n\n/**\n * convert xyz-d50 to lab\n * @param {Array.<number>} xyz - [x, y, z, a] x|y|z|a: 0..1\n * @returns {Array.<number>} - [l, a, b, aa] l: 0..100 a|b: -125..125 aa: 0..1\n */\nexport const convertXyzD50ToLab = xyz => {\n  const [x, y, z, aa] = validateColorComponents(xyz, {\n    validateRange: false\n  });\n  const xyzD50 = [x, y, z].map((val, i) => val / D50[i]);\n  const [f0, f1, f2] = xyzD50.map(val => val > LAB_EPSILON\n    ? Math.cbrt(val)\n    : (val * LAB_KAPPA + HEX) / LAB_L\n  );\n  const l = Math.min(Math.max((LAB_L * f1) - HEX, 0), MAX_PCT);\n  let a, b;\n  if (l === 0 || l === MAX_PCT) {\n    a = NONE;\n    b = NONE;\n  } else {\n    a = (f0 - f1) * LAB_A;\n    b = (f1 - f2) * LAB_B;\n  }\n  return [l, a, b, aa];\n};\n\n/**\n * convert xyz-d50 to lch\n * @param {Array.<number>} xyz - [x, y, z, a] x|y|z|a: 0..1\n * @returns {Array.<number>} - [l, c, h, a] l: 0..100 c: 0..150 h: 0..360 a: 0..1\n */\nexport const convertXyzD50ToLch = xyz => {\n  const [l, a, b, aa] = convertXyzD50ToLab(xyz);\n  let c, h;\n  if (l === 0 || l === MAX_PCT) {\n    c = NONE;\n    h = NONE;\n  } else {\n    c =\n      Math.max(Math.sqrt(Math.pow(a, POW_SQUARE) + Math.pow(b, POW_SQUARE)), 0);\n    if (parseFloat(c.toFixed(QUAT)) === 0) {\n      h = NONE;\n    } else {\n      h = Math.atan2(b, a) * DEG * HALF / Math.PI;\n      if (h < 0) {\n        h += DEG;\n      }\n    }\n  }\n  return [l, c, h, aa];\n};\n\n/**\n * convert hex color to rgb\n * @param {string} value - color value\n * @returns {Array.<number>} - [r, g, b, a] r|g|b: 0..255 a: 0..1\n */\nexport const convertHexToRgb = value => {\n  if (isString(value)) {\n    value = value.toLowerCase().trim();\n  } else {\n    throw new TypeError(`Expected String but got ${getType(value)}.`);\n  }\n  if (!(/^#[\\da-f]{6}$/.test(value) || /^#[\\da-f]{3}$/.test(value) ||\n        /^#[\\da-f]{8}$/.test(value) || /^#[\\da-f]{4}$/.test(value))) {\n    throw new Error(`Invalid property value: ${value}`);\n  }\n  const arr = [];\n  if (/^#[\\da-f]{6}$/.test(value)) {\n    const [, r, g, b] = value.match(/^#([\\da-f]{2})([\\da-f]{2})([\\da-f]{2})$/);\n    arr.push(\n      parseInt(r, HEX),\n      parseInt(g, HEX),\n      parseInt(b, HEX),\n      1\n    );\n  } else if (/^#[\\da-f]{3}$/.test(value)) {\n    const [, r, g, b] = value.match(/^#([\\da-f])([\\da-f])([\\da-f])$/);\n    arr.push(\n      parseInt(`${r}${r}`, HEX),\n      parseInt(`${g}${g}`, HEX),\n      parseInt(`${b}${b}`, HEX),\n      1\n    );\n  } else if (/^#[\\da-f]{8}$/.test(value)) {\n    const [, r, g, b, a] =\n      value.match(/^#([\\da-f]{2})([\\da-f]{2})([\\da-f]{2})([\\da-f]{2})$/);\n    arr.push(\n      parseInt(r, HEX),\n      parseInt(g, HEX),\n      parseInt(b, HEX),\n      parseInt(a, HEX) / MAX_RGB\n    );\n  } else if (/^#[\\da-f]{4}$/.test(value)) {\n    const [, r, g, b, a] =\n      value.match(/^#([\\da-f])([\\da-f])([\\da-f])([\\da-f])$/);\n    arr.push(\n      parseInt(`${r}${r}`, HEX),\n      parseInt(`${g}${g}`, HEX),\n      parseInt(`${b}${b}`, HEX),\n      parseInt(`${a}${a}`, HEX) / MAX_RGB\n    );\n  }\n  return arr;\n};\n\n/**\n * convert hex color to linear rgb\n * @param {string} value - color value\n * @returns {Array.<number>} - [r, g, b, a] r|g|b|a: 0..1\n */\nexport const convertHexToLinearRgb = value => {\n  const [rr, gg, bb, a] = convertHexToRgb(value);\n  const [r, g, b] = convertRgbToLinearRgb([rr, gg, bb]);\n  return [r, g, b, a];\n};\n\n/**\n * convert hex color to xyz\n * @param {string} value - color value\n * @returns {Array.<number>} - [x, y, z, a] x|y|z|a: 0..1\n */\nexport const convertHexToXyz = value => {\n  const [r, g, b, a] = convertHexToLinearRgb(value);\n  const [x, y, z] = transformMatrix(MATRIX_RGB_TO_XYZ, [r, g, b]);\n  return [x, y, z, a];\n};\n\n/**\n * parse alpha\n * @param {?string} [a] - alpha value\n * @returns {number} - a: 0..1\n */\nexport const parseAlpha = a => {\n  if (isString(a)) {\n    a = a.trim();\n    if (!a) {\n      a = 1;\n    } else if (a === NONE) {\n      a = 0;\n    } else {\n      if (a.startsWith('.')) {\n        a = `0${a}`;\n      }\n      if (a.endsWith('%')) {\n        a = parseFloat(a) / MAX_PCT;\n      } else {\n        a = parseFloat(a);\n      }\n      if (Number.isNaN(a)) {\n        throw new TypeError(`${a} is not a number.`);\n      }\n      if (a < 0 || a > 1) {\n        a = Math.min(Math.max(a, 0), 1);\n      }\n    }\n  } else {\n    a = 1;\n  }\n  return a;\n};\n\n/**\n * parse rgb()\n * @param {string} value - color value\n * @returns {Array.<number>} - [r, g, b, a] r|g|b: 0..255 a: 0..1\n */\nexport const parseRgb = value => {\n  if (isString(value)) {\n    value = value.trim();\n  } else {\n    throw new TypeError(`Expected String but got ${getType(value)}.`);\n  }\n  const reg =\n    new RegExp(`^rgba?\\\\(\\\\s*(${REG_RGB}|${REG_RGB_LV3})\\\\s*\\\\)$`);\n  if (!reg.test(value)) {\n    throw new Error(`Invalid property value: ${value}`);\n  }\n  const [, val] = value.match(reg);\n  let [r, g, b, a] = val.replace(/[,/]/g, ' ').split(/\\s+/);\n  if (r === NONE) {\n    r = 0;\n  } else {\n    if (r.startsWith('.')) {\n      r = `0${r}`;\n    }\n    if (r.endsWith('%')) {\n      r = parseFloat(r) * MAX_RGB / MAX_PCT;\n    } else {\n      r = parseFloat(r);\n    }\n  }\n  if (g === NONE) {\n    g = 0;\n  } else {\n    if (g.startsWith('.')) {\n      g = `0${g}`;\n    }\n    if (g.endsWith('%')) {\n      g = parseFloat(g) * MAX_RGB / MAX_PCT;\n    } else {\n      g = parseFloat(g);\n    }\n  }\n  if (b === NONE) {\n    b = 0;\n  } else {\n    if (b.startsWith('.')) {\n      b = `0${b}`;\n    }\n    if (b.endsWith('%')) {\n      b = parseFloat(b) * MAX_RGB / MAX_PCT;\n    } else {\n      b = parseFloat(b);\n    }\n  }\n  a = parseAlpha(a);\n  return [\n    Math.min(Math.max(r, 0), MAX_RGB),\n    Math.min(Math.max(g, 0), MAX_RGB),\n    Math.min(Math.max(b, 0), MAX_RGB),\n    a\n  ];\n};\n\n/**\n * parse hsl()\n * @param {string} value - color value\n * @returns {Array.<number>} - [r, g, b, a] r|g|b: 0..255 a: 0..1\n */\nexport const parseHsl = value => {\n  if (isString(value)) {\n    value = value.trim();\n  } else {\n    throw new TypeError(`Expected String but got ${getType(value)}.`);\n  }\n  const reg = new RegExp(`^hsla?\\\\(\\\\s*(${REG_HSL}|${REG_HSL_LV3})\\\\s*\\\\)$`);\n  if (!reg.test(value)) {\n    throw new Error(`Invalid property value: ${value}`);\n  }\n  const [, val] = value.match(reg);\n  let [h, s, l, a] = val.replace(/[,/]/g, ' ').split(/\\s+/);\n  if (h === NONE) {\n    h = 0;\n  } else {\n    h = angleToDeg(h);\n  }\n  if (s === NONE) {\n    s = 0;\n  } else {\n    if (s.startsWith('.')) {\n      s = `0${s}`;\n    }\n    s = Math.min(Math.max(parseFloat(s), 0), MAX_PCT);\n  }\n  if (l === NONE) {\n    l = 0;\n  } else {\n    if (l.startsWith('.')) {\n      l = `0${l}`;\n    }\n    l = Math.min(Math.max(parseFloat(l), 0), MAX_PCT);\n  }\n  a = parseAlpha(a);\n  let max, min;\n  if (l < MAX_PCT * HALF) {\n    max = (l + l * (s / MAX_PCT)) * MAX_RGB / MAX_PCT;\n    min = (l - l * (s / MAX_PCT)) * MAX_RGB / MAX_PCT;\n  } else {\n    max = (l + (MAX_PCT - l) * (s / MAX_PCT)) * MAX_RGB / MAX_PCT;\n    min = (l - (MAX_PCT - l) * (s / MAX_PCT)) * MAX_RGB / MAX_PCT;\n  }\n  const factor = (max - min) / DEG_INTERVAL;\n  let r, g, b;\n  // < 60\n  if (h >= 0 && h < DEG_INTERVAL) {\n    r = max;\n    g = h * factor + min;\n    b = min;\n  // < 120\n  } else if (h < DEG_INTERVAL * DUO) {\n    r = (DEG_INTERVAL * DUO - h) * factor + min;\n    g = max;\n    b = min;\n  // < 180\n  } else if (h < DEG * HALF) {\n    r = min;\n    g = max;\n    b = (h - DEG_INTERVAL * DUO) * factor + min;\n  // < 240\n  } else if (h < DEG_INTERVAL * QUAT) {\n    r = min;\n    g = (DEG_INTERVAL * QUAT - h) * factor + min;\n    b = max;\n  // < 300\n  } else if (h < DEG - DEG_INTERVAL) {\n    r = (h - (DEG_INTERVAL * QUAT)) * factor + min;\n    g = min;\n    b = max;\n  // < 360\n  } else if (h < DEG) {\n    r = max;\n    g = min;\n    b = (DEG - h) * factor + min;\n  }\n  return [\n    Math.min(Math.max(r, 0), MAX_RGB),\n    Math.min(Math.max(g, 0), MAX_RGB),\n    Math.min(Math.max(b, 0), MAX_RGB),\n    a\n  ];\n};\n\n/**\n * parse hwb()\n * @param {string} value - color value\n * @returns {Array.<number>} - [r, g, b, a] r|g|b: 0..255 a: 0..1\n */\nexport const parseHwb = value => {\n  if (isString(value)) {\n    value = value.trim();\n  } else {\n    throw new TypeError(`Expected String but got ${getType(value)}.`);\n  }\n  const reg = new RegExp(`^hwb\\\\(\\\\s*(${REG_HSL})\\\\s*\\\\)$`);\n  if (!reg.test(value)) {\n    throw new Error(`Invalid property value: ${value}`);\n  }\n  const [, val] = value.match(reg);\n  let [h, w, b, a] = val.replace('/', ' ').split(/\\s+/);\n  if (h === NONE) {\n    h = 0;\n  } else {\n    h = angleToDeg(h);\n  }\n  if (w === NONE) {\n    w = 0;\n  } else {\n    if (w.startsWith('.')) {\n      w = `0${w}`;\n    }\n    w = Math.min(Math.max(parseFloat(w), 0), MAX_PCT) / MAX_PCT;\n  }\n  if (b === NONE) {\n    b = 0;\n  } else {\n    if (b.startsWith('.')) {\n      b = `0${b}`;\n    }\n    b = Math.min(Math.max(parseFloat(b), 0), MAX_PCT) / MAX_PCT;\n  }\n  a = parseAlpha(a);\n  const arr = [];\n  if (w + b >= 1) {\n    const v = (w / (w + b)) * MAX_RGB;\n    arr.push(v, v, v, a);\n  } else {\n    const [rr, gg, bb] = parseHsl(`hsl(${h} 100% 50%)`);\n    const factor = (1 - w - b) / MAX_RGB;\n    arr.push(\n      (rr * factor + w) * MAX_RGB,\n      (gg * factor + w) * MAX_RGB,\n      (bb * factor + w) * MAX_RGB,\n      a\n    );\n  }\n  return arr;\n};\n\n/**\n + parse lab()\n * @param {string} value - color value\n * @returns {Array.<number>} - [x, y, z, a] x|y|z|a: 0..1\n */\nexport const parseLab = value => {\n  if (isString(value)) {\n    value = value.trim();\n  } else {\n    throw new TypeError(`Expected String but got ${getType(value)}.`);\n  }\n  const reg = new RegExp(`^lab\\\\(\\\\s*(${REG_LAB})\\\\s*\\\\)$`);\n  if (!reg.test(value)) {\n    throw new Error(`Invalid property value: ${value}`);\n  }\n  const COEF_PCT = 1.25;\n  const COND_POW = 8;\n  const [, val] = value.match(reg);\n  let [l, a, b, aa] = val.replace('/', ' ').split(/\\s+/);\n  if (l === NONE) {\n    l = 0;\n  } else {\n    if (l.startsWith('.')) {\n      l = `0${l}`;\n    }\n    if (l.endsWith('%')) {\n      l = parseFloat(l);\n      if (l > MAX_PCT) {\n        l = MAX_PCT;\n      }\n    } else {\n      l = parseFloat(l);\n    }\n    if (l < 0) {\n      l = 0;\n    }\n  }\n  if (a === NONE) {\n    a = 0;\n  } else {\n    if (a.startsWith('.')) {\n      a = `0${a}`;\n    }\n    if (a.endsWith('%')) {\n      a = parseFloat(a) * COEF_PCT;\n    } else {\n      a = parseFloat(a);\n    }\n  }\n  if (b === NONE) {\n    b = 0;\n  } else {\n    if (b.endsWith('%')) {\n      b = parseFloat(b) * COEF_PCT;\n    } else {\n      b = parseFloat(b);\n    }\n  }\n  aa = parseAlpha(aa);\n  const fl = (l + HEX) / LAB_L;\n  const fa = (a / LAB_A + fl);\n  const fb = (fl - b / LAB_B);\n  const powFl = Math.pow(fl, POW_CUBE);\n  const powFa = Math.pow(fa, POW_CUBE);\n  const powFb = Math.pow(fb, POW_CUBE);\n  const xyz = [\n    powFa > LAB_EPSILON ? powFa : (fa * LAB_L - HEX) / LAB_KAPPA,\n    l > COND_POW ? powFl : l / LAB_KAPPA,\n    powFb > LAB_EPSILON ? powFb : (fb * LAB_L - HEX) / LAB_KAPPA\n  ];\n  const [x, y, z] = xyz.map((val, i) => val * D50[i]);\n  return [x, y, z, aa];\n};\n\n/**\n + parse lch()\n * @param {string} value - color value\n * @returns {Array.<number>} - [x, y, z, a] x|y|z|a: 0..1\n */\nexport const parseLch = value => {\n  if (isString(value)) {\n    value = value.trim();\n  } else {\n    throw new TypeError(`Expected String but got ${getType(value)}.`);\n  }\n  const reg = new RegExp(`^lch\\\\(\\\\s*(${REG_LCH})\\\\s*\\\\)$`);\n  if (!reg.test(value)) {\n    throw new Error(`Invalid property value: ${value}`);\n  }\n  const COEF_PCT = 1.5;\n  const [, val] = value.match(reg);\n  let [l, c, h, aa] = val.replace('/', ' ').split(/\\s+/);\n  if (l === NONE) {\n    l = 0;\n  } else {\n    if (l.startsWith('.')) {\n      l = `0${l}`;\n    }\n    l = parseFloat(l);\n    if (l < 0) {\n      l = 0;\n    }\n  }\n  if (c === NONE) {\n    c = 0;\n  } else {\n    if (c.startsWith('.')) {\n      c = `0${c}`;\n    }\n    if (c.endsWith('%')) {\n      c = parseFloat(c) * COEF_PCT;\n    } else {\n      c = parseFloat(c);\n    }\n  }\n  if (h === NONE) {\n    h = 0;\n  } else {\n    h = angleToDeg(h);\n  }\n  aa = parseAlpha(aa);\n  const a = c * Math.cos(h * Math.PI / (DEG * HALF));\n  const b = c * Math.sin(h * Math.PI / (DEG * HALF));\n  const [x, y, z] = parseLab(`lab(${l} ${a} ${b})`);\n  return [x, y, z, aa];\n};\n\n/**\n * parse oklab()\n * @param {string} value - color value\n * @returns {Array.<number>} - [x, y, z, a] x|y|z|a: 0..1\n */\nexport const parseOklab = value => {\n  if (isString(value)) {\n    value = value.trim();\n  } else {\n    throw new TypeError(`Expected String but got ${getType(value)}.`);\n  }\n  const reg = new RegExp(`^oklab\\\\(\\\\s*(${REG_LAB})\\\\s*\\\\)$`);\n  if (!reg.test(value)) {\n    throw new Error(`Invalid property value: ${value}`);\n  }\n  const COEF_PCT = 0.4;\n  const [, val] = value.match(reg);\n  let [l, a, b, aa] = val.replace('/', ' ').split(/\\s+/);\n  if (l === NONE) {\n    l = 0;\n  } else {\n    if (l.startsWith('.')) {\n      l = `0${l}`;\n    }\n    if (l.endsWith('%')) {\n      l = parseFloat(l) / MAX_PCT;\n    } else {\n      l = parseFloat(l);\n    }\n    if (l < 0) {\n      l = 0;\n    }\n  }\n  if (a === NONE) {\n    a = 0;\n  } else {\n    if (a.startsWith('.')) {\n      a = `0${a}`;\n    }\n    if (a.endsWith('%')) {\n      a = parseFloat(a) * COEF_PCT / MAX_PCT;\n    } else {\n      a = parseFloat(a);\n    }\n  }\n  if (b === NONE) {\n    b = 0;\n  } else {\n    if (b.endsWith('%')) {\n      b = parseFloat(b) * COEF_PCT / MAX_PCT;\n    } else {\n      b = parseFloat(b);\n    }\n  }\n  aa = parseAlpha(aa);\n  const lms = transformMatrix(MATRIX_OKLAB_TO_LMS, [l, a, b]);\n  const xyzLms = lms.map(c => Math.pow(c, POW_CUBE));\n  const [x, y, z] = transformMatrix(MATRIX_LMS_TO_XYZ, xyzLms);\n  return [x, y, z, aa];\n};\n\n/**\n * parse oklch()\n * @param {string} value - color value\n * @returns {Array.<number>} - [x, y, z, a] x|y|z|a: 0..1\n */\nexport const parseOklch = value => {\n  if (isString(value)) {\n    value = value.trim();\n  } else {\n    throw new TypeError(`Expected String but got ${getType(value)}.`);\n  }\n  const reg = new RegExp(`^oklch\\\\(\\\\s*(${REG_LAB})\\\\s*\\\\)$`);\n  if (!reg.test(value)) {\n    throw new Error(`Invalid property value: ${value}`);\n  }\n  const COEF_PCT = 0.4;\n  const [, val] = value.match(reg);\n  let [l, c, h, aa] = val.replace('/', ' ').split(/\\s+/);\n  if (l === NONE) {\n    l = 0;\n  } else {\n    if (l.startsWith('.')) {\n      l = `0${l}`;\n    }\n    if (l.endsWith('%')) {\n      l = parseFloat(l) / MAX_PCT;\n    } else {\n      l = parseFloat(l);\n    }\n    if (l < 0) {\n      l = 0;\n    }\n  }\n  if (c === NONE) {\n    c = 0;\n  } else {\n    if (c.startsWith('.')) {\n      c = `0${c}`;\n    }\n    if (c.endsWith('%')) {\n      c = parseFloat(c) * COEF_PCT / MAX_PCT;\n    } else {\n      c = parseFloat(c);\n    }\n    if (c < 0) {\n      c = 0;\n    }\n  }\n  if (h === NONE) {\n    h = 0;\n  } else {\n    h = angleToDeg(h);\n  }\n  aa = parseAlpha(aa);\n  const a = c * Math.cos(h * Math.PI / (DEG * HALF));\n  const b = c * Math.sin(h * Math.PI / (DEG * HALF));\n  const lms = transformMatrix(MATRIX_OKLAB_TO_LMS, [l, a, b]);\n  const xyzLms = lms.map(cl => Math.pow(cl, POW_CUBE));\n  const [x, y, z] = transformMatrix(MATRIX_LMS_TO_XYZ, xyzLms);\n  return [x, y, z, aa];\n};\n\n/**\n * parse color()\n * @param {string} value - color value\n * @param {boolean} d50 - xyz in d50 white point\n * @returns {Array.<number>} - [x, y, z, a] x|y|z|a: 0..1\n */\nexport const parseColorFunc = (value, d50 = false) => {\n  if (isString(value)) {\n    value = value.trim();\n  } else {\n    throw new TypeError(`Expected String but got ${getType(value)}.`);\n  }\n  const reg = new RegExp(`^color\\\\(\\\\s*(${REG_COLOR_FUNC})\\\\s*\\\\)$`);\n  if (!reg.test(value)) {\n    throw new Error(`Invalid property value: ${value}`);\n  }\n  const [, val] = value.match(reg);\n  const [cs, v1, v2, v3, v4] = val.replace('/', ' ').split(/\\s+/);\n  let r, g, b;\n  if (v1 === NONE) {\n    r = 0;\n  } else {\n    let rr;\n    if (v1.startsWith('.')) {\n      rr = `0${v1}`;\n    } else {\n      rr = v1;\n    }\n    r = rr.endsWith('%') ? parseFloat(rr) / MAX_PCT : parseFloat(rr);\n  }\n  if (v2 === NONE) {\n    g = 0;\n  } else {\n    let gg;\n    if (v2.startsWith('.')) {\n      gg = `0${v2}`;\n    } else {\n      gg = v2;\n    }\n    g = gg.endsWith('%') ? parseFloat(gg) / MAX_PCT : parseFloat(gg);\n  }\n  if (v3 === NONE) {\n    b = 0;\n  } else {\n    let bb;\n    if (v3.startsWith('.')) {\n      bb = `0${v3}`;\n    } else {\n      bb = v3;\n    }\n    b = bb.endsWith('%') ? parseFloat(bb) / MAX_PCT : parseFloat(bb);\n  }\n  const a = parseAlpha(v4);\n  let x, y, z;\n  // srgb\n  if (cs === 'srgb') {\n    [x, y, z] = convertRgbToXyz([r * MAX_RGB, g * MAX_RGB, b * MAX_RGB]);\n    if (d50) {\n      [x, y, z] = transformMatrix(MATRIX_D65_TO_D50, [x, y, z]);\n    }\n  // srgb-linear\n  } else if (cs === 'srgb-linear') {\n    [x, y, z] = transformMatrix(MATRIX_RGB_TO_XYZ, [r, g, b]);\n    if (d50) {\n      [x, y, z] = transformMatrix(MATRIX_D65_TO_D50, [x, y, z]);\n    }\n  // display-p3\n  } else if (cs === 'display-p3') {\n    const linearRgb = convertRgbToLinearRgb([\n      r * MAX_RGB,\n      g * MAX_RGB,\n      b * MAX_RGB\n    ]);\n    [x, y, z] = transformMatrix(MATRIX_P3_TO_XYZ, linearRgb);\n    if (d50) {\n      [x, y, z] = transformMatrix(MATRIX_D65_TO_D50, [x, y, z]);\n    }\n  // rec2020\n  } else if (cs === 'rec2020') {\n    const ALPHA = 1.09929682680944;\n    const BETA = 0.018053968510807;\n    const REC_COEF = 0.45;\n    const rgb = [r, g, b].map(c => {\n      let cl;\n      if (c < BETA * REC_COEF * DEC) {\n        cl = c / (REC_COEF * DEC);\n      } else {\n        cl = Math.pow((c + ALPHA - 1) / ALPHA, 1 / REC_COEF);\n      }\n      return cl;\n    });\n    [x, y, z] = transformMatrix(MATRIX_REC2020_TO_XYZ, rgb);\n    if (d50) {\n      [x, y, z] = transformMatrix(MATRIX_D65_TO_D50, [x, y, z]);\n    }\n  // a98-rgb\n  } else if (cs === 'a98-rgb') {\n    const POW_A98 = 563 / 256;\n    const rgb = [r, g, b].map(c => {\n      const cl = Math.pow(c, POW_A98);\n      return cl;\n    });\n    [x, y, z] = transformMatrix(MATRIX_A98_TO_XYZ, rgb);\n    if (d50) {\n      [x, y, z] = transformMatrix(MATRIX_D65_TO_D50, [x, y, z]);\n    }\n  // prophoto-rgb\n  } else if (cs === 'prophoto-rgb') {\n    const POW_PROPHOTO = 1.8;\n    const rgb = [r, g, b].map(c => {\n      let cl;\n      if (c > 1 / (HEX * DUO)) {\n        cl = Math.pow(c, POW_PROPHOTO);\n      } else {\n        cl = c / HEX;\n      }\n      return cl;\n    });\n    [x, y, z] = transformMatrix(MATRIX_PROPHOTO_TO_XYZ_D50, rgb);\n    if (!d50) {\n      [x, y, z] = transformMatrix(MATRIX_D50_TO_D65, [x, y, z]);\n    }\n  // xyz, xyz-d50, xyz-d65\n  } else if (/^xyz(?:-d(?:50|65))?$/.test(cs)) {\n    [x, y, z] = [r, g, b];\n    if (cs === 'xyz-d50') {\n      if (!d50) {\n        [x, y, z] = transformMatrix(MATRIX_D50_TO_D65, [x, y, z]);\n      }\n    } else if (d50) {\n      [x, y, z] = transformMatrix(MATRIX_D65_TO_D50, [x, y, z]);\n    }\n  }\n  return [x, y, z, a];\n};\n\n/**\n * parse color value\n * @param {string} value - color value\n * @param {boolean} [d50] - xyz in d50 white point\n * @returns {Array.<number>} - [x, y, z, a] x|y|z|a: 0..1\n */\nexport const parseColorValue = (value, d50 = false) => {\n  if (isString(value)) {\n    value = value.toLowerCase().trim();\n  } else {\n    throw new TypeError(`Expected String but got ${getType(value)}.`);\n  }\n  let x, y, z, a;\n  // complement currentcolor as a missing color\n  if (REG_CURRENT_COLOR.test(value)) {\n    x = 0;\n    y = 0;\n    z = 0;\n    a = 0;\n  // named-color\n  } else if (/^[a-z]+$/.test(value)) {\n    if (Object.prototype.hasOwnProperty.call(NAMED_COLORS, value)) {\n      const [r, g, b] = NAMED_COLORS[value];\n      a = 1;\n      [x, y, z] = convertRgbToXyz([r, g, b]);\n      if (d50) {\n        [x, y, z] = transformMatrix(MATRIX_D65_TO_D50, [x, y, z]);\n      }\n    } else if (value === 'transparent') {\n      x = 0;\n      y = 0;\n      z = 0;\n      a = 0;\n    } else {\n      throw new Error(`Invalid property value: ${value}`);\n    }\n  // hex-color\n  } else if (value.startsWith('#')) {\n    let hex;\n    if (/^#[\\da-f]{6}$/.test(value)) {\n      hex = value;\n    } else if (/^#[\\da-f]{3}$/.test(value)) {\n      const [, r, g, b] = value.match(/^#([\\da-f])([\\da-f])([\\da-f])$/);\n      hex = `#${r}${r}${g}${g}${b}${b}`;\n    } else if (/^#[\\da-f]{8}$/.test(value)) {\n      hex = value;\n    } else if (/^#[\\da-f]{4}$/.test(value)) {\n      const [, r, g, b, aa] =\n        value.match(/^#([\\da-f])([\\da-f])([\\da-f])([\\da-f])$/);\n      hex = `#${r}${r}${g}${g}${b}${b}${aa}${aa}`;\n    } else {\n      throw new Error(`Invalid property value: ${value}`);\n    }\n    [x, y, z, a] = convertHexToXyz(hex);\n    if (d50) {\n      [x, y, z] = transformMatrix(MATRIX_D65_TO_D50, [x, y, z]);\n    }\n  // lab()\n  } else if (value.startsWith('lab')) {\n    [x, y, z, a] = parseLab(value);\n    if (!d50) {\n      [x, y, z] = transformMatrix(MATRIX_D50_TO_D65, [x, y, z]);\n    }\n  // lch()\n  } else if (value.startsWith('lch')) {\n    [x, y, z, a] = parseLch(value);\n    if (!d50) {\n      [x, y, z] = transformMatrix(MATRIX_D50_TO_D65, [x, y, z]);\n    }\n  // oklab()\n  } else if (value.startsWith('oklab')) {\n    [x, y, z, a] = parseOklab(value);\n    if (d50) {\n      [x, y, z] = transformMatrix(MATRIX_D65_TO_D50, [x, y, z]);\n    }\n  // oklch()\n  } else if (value.startsWith('oklch')) {\n    [x, y, z, a] = parseOklch(value);\n    if (d50) {\n      [x, y, z] = transformMatrix(MATRIX_D65_TO_D50, [x, y, z]);\n    }\n  } else {\n    let r, g, b;\n    // rgb()\n    if (value.startsWith('rgb')) {\n      [r, g, b, a] = parseRgb(value);\n    // hsl()\n    } else if (value.startsWith('hsl')) {\n      [r, g, b, a] = parseHsl(value);\n    // hwb()\n    } else if (value.startsWith('hwb')) {\n      [r, g, b, a] = parseHwb(value);\n    } else {\n      throw new Error(`Invalid property value: ${value}`);\n    }\n    [x, y, z] = convertRgbToXyz([r, g, b]);\n    if (d50) {\n      [x, y, z] = transformMatrix(MATRIX_D65_TO_D50, [x, y, z]);\n    }\n  }\n  return [x, y, z, a];\n};\n\n/**\n * convert color value to linear rgb\n * @param {string} value - color value\n * @param {object} [opt] - options\n * @returns {Array.<number>} - [r, g, b, a] r|g|b|a: 0..1\n */\nexport const convertColorValueToLinearRgb = (value, opt = {}) => {\n  if (isString(value)) {\n    value = value.trim();\n  } else {\n    throw new TypeError(`Expected String but got ${getType(value)}.`);\n  }\n  const { alpha } = opt;\n  let x, y, z, a;\n  if (value.startsWith('color(')) {\n    [x, y, z, a] = parseColorFunc(value);\n  } else {\n    [x, y, z, a] = parseColorValue(value);\n  }\n  let [r, g, b] = transformMatrix(MATRIX_XYZ_TO_RGB, [x, y, z]);\n  r = Math.min(Math.max(r, 0), 1);\n  g = Math.min(Math.max(g, 0), 1);\n  b = Math.min(Math.max(b, 0), 1);\n  const rgb = [r, g, b];\n  if (alpha) {\n    rgb.push(a);\n  } else {\n    rgb.push(1);\n  }\n  return rgb;\n};\n\n/**\n * convert color value to rgb\n * @param {string} value - color value\n * @returns {Array.<number>} - [r, g, b, a] r|g|b: 0..255 a: 0..1\n */\nexport const convertColorValueToRgb = value => {\n  let [r, g, b, a] = convertColorValueToLinearRgb(value, {\n    alpha: true\n  });\n  [r, g, b] = convertLinearRgbToRgb([r, g, b]);\n  return [r, g, b, a];\n};\n\n/**\n * resolve color value\n * @param {string} value - color value\n * @returns {Array.<number>} - [r, g, b, a] r|g|b: 0..255 a: 0..1\n */\nexport const resolveColorValue = value => {\n  if (isString(value)) {\n    value = value.toLowerCase().trim();\n  } else {\n    throw new TypeError(`Expected String but got ${getType(value)}.`);\n  }\n  let r, g, b, a;\n  // complement currentcolor as a missing color\n  if (REG_CURRENT_COLOR.test(value)) {\n    r = 0;\n    g = 0;\n    b = 0;\n    a = 0;\n  // named-color\n  } else if (/^[a-z]+$/i.test(value)) {\n    if (Object.prototype.hasOwnProperty.call(NAMED_COLORS, value)) {\n      [r, g, b] = NAMED_COLORS[value];\n      a = 1;\n    } else if (value === 'transparent') {\n      r = 0;\n      g = 0;\n      b = 0;\n      a = 0;\n    }\n  // hex-color\n  } else if (value.startsWith('#')) {\n    [r, g, b, a] = convertHexToRgb(value);\n  // lab(), lch()\n  } else if (/^l(?:ab|ch)/.test(value)) {\n    let x, y, z;\n    if (value.startsWith('lab')) {\n      [x, y, z, a] = parseLab(value);\n    } else {\n      [x, y, z, a] = parseLch(value);\n    }\n    [r, g, b, a] = convertXyzD50ToRgb([x, y, z, a]);\n  // oklab(), oklch()\n  } else if (/^okl(?:ab|ch)/.test(value)) {\n    let x, y, z;\n    if (value.startsWith('oklab')) {\n      [x, y, z, a] = parseOklab(value);\n    } else {\n      [x, y, z, a] = parseOklch(value);\n    }\n    [r, g, b, a] = convertXyzToRgb([x, y, z, a]);\n  // rgb()\n  } else if (value.startsWith('rgb')) {\n    [r, g, b, a] = parseRgb(value);\n  // hsl()\n  } else if (value.startsWith('hsl')) {\n    [r, g, b, a] = parseHsl(value);\n  // hwb()\n  } else if (value.startsWith('hwb')) {\n    [r, g, b, a] = parseHwb(value);\n  }\n  let res;\n  if (isNaN(r) || isNaN(g) || isNaN(b) || isNaN(a)) {\n    res = [];\n  } else {\n    res = [\n      Math.round(r),\n      Math.round(g),\n      Math.round(b),\n      a\n    ];\n  }\n  return res;\n};\n\n/**\n * resolve color()\n * @param {string} value - color value\n * @returns {Array.<number>} - [r, g, b, a] r|g|b: 0..255 a: 0..1\n */\nexport const resolveColorFunc = value => {\n  if (isString(value)) {\n    value = value.trim();\n  } else {\n    throw new TypeError(`Expected String but got ${getType(value)}.`);\n  }\n  const reg = new RegExp(`^color\\\\(\\\\s*${REG_COLOR_FUNC}\\\\s*\\\\)$`);\n  if (!reg.test(value)) {\n    throw new Error(`Invalid property value: ${value}`);\n  }\n  const [x, y, z, a] = parseColorFunc(value);\n  const [r, g, b] = convertXyzToRgb([x, y, z]);\n  return [r, g, b, a];\n};\n\n/**\n * resolve color-mix()\n * @param {string} value - color value\n * @param {object} [opt] - options\n * @returns {Array.<number>} - [r, g, b, a] r|g|b: 0..255 a: 0..1\n */\nexport const resolveColorMix = (value, opt = {}) => {\n  if (isString(value)) {\n    value = value.trim();\n  } else {\n    throw new TypeError(`Expected String but got ${getType(value)}.`);\n  }\n  const regColorMix = new RegExp(`^${REG_COLOR_MIX_CAPT}$`, 'i');\n  if (!regColorMix.test(value)) {\n    throw new Error(`Invalid property value: ${value}`);\n  }\n  const CC_LCH = 'lch(none none none / none)';\n  const CC_RGB = 'rgb(none none none / none)';\n  const regColorPart =\n    new RegExp(`^(${REG_COLOR_TYPE})(?:\\\\s+(${REG_PCT}))?$`, 'i');\n  const regMissingColor = new RegExp(NONE);\n  const [, colorSpace, colorPartA, colorPartB] = value.match(regColorMix);\n  const [, colorA, pctA] = colorPartA.match(regColorPart);\n  const [, colorB, pctB] = colorPartB.match(regColorPart);\n  // normalize percentages and set multipler\n  let pA, pB, m;\n  if (pctA && pctB) {\n    const p1 = parseFloat(pctA) / MAX_PCT;\n    const p2 = parseFloat(pctB) / MAX_PCT;\n    if (p1 < 0 || p1 > 1) {\n      throw new RangeError(`${pctA} is not between 0% and 100%.`);\n    }\n    if (p2 < 0 || p2 > 1) {\n      throw new RangeError(`${pctB} is not between 0% and 100%.`);\n    }\n    const factor = p1 + p2;\n    if (factor === 0) {\n      throw new Error(`Invalid property value: ${value}`);\n    }\n    pA = p1 / factor;\n    pB = p2 / factor;\n    m = factor < 1 ? factor : 1;\n  } else {\n    if (pctA) {\n      pA = parseFloat(pctA) / MAX_PCT;\n      if (pA < 0 || pA > 1) {\n        throw new RangeError(`${pctA} is not between 0% and 100%.`);\n      }\n      pB = 1 - pA;\n    } else if (pctB) {\n      pB = parseFloat(pctB) / MAX_PCT;\n      if (pB < 0 || pB > 1) {\n        throw new RangeError(`${pctB} is not between 0% and 100%.`);\n      }\n      pA = 1 - pB;\n    } else {\n      pA = HALF;\n      pB = HALF;\n    }\n    m = 1;\n  }\n  let r, g, b, a;\n  // in srgb\n  if (colorSpace === 'srgb') {\n    let rgbA = convertColorValueToRgb(colorA, {\n      alpha: true\n    });\n    let rgbB = convertColorValueToRgb(colorB, {\n      alpha: true\n    });\n    if (REG_CURRENT_COLOR.test(colorA)) {\n      rgbA = reInsertMissingColorComponents(CC_RGB, rgbA);\n    } else if (regMissingColor.test(colorA)) {\n      rgbA = reInsertMissingColorComponents(colorA, rgbA);\n    }\n    if (REG_CURRENT_COLOR.test(colorB)) {\n      rgbB = reInsertMissingColorComponents(CC_RGB, rgbB);\n    } else if (regMissingColor.test(colorB)) {\n      rgbB = reInsertMissingColorComponents(colorB, rgbB);\n    }\n    const [\n      [rA, gA, bA, aA],\n      [rB, gB, bB, aB]\n    ] = normalizeColorComponents(rgbA, rgbB);\n    const factorA = aA * pA;\n    const factorB = aB * pB;\n    a = (factorA + factorB);\n    if (a === 0) {\n      r = rA * pA + rB * pB;\n      g = gA * pA + gB * pB;\n      b = bA * pA + bB * pB;\n    } else {\n      r = (rA * factorA + rB * factorB) / a;\n      g = (gA * factorA + gB * factorB) / a;\n      b = (bA * factorA + bB * factorB) / a;\n    }\n  // in srgb-linear\n  } else if (colorSpace === 'srgb-linear') {\n    let rgbA = convertColorValueToLinearRgb(colorA, {\n      alpha: true\n    });\n    let rgbB = convertColorValueToLinearRgb(colorB, {\n      alpha: true\n    });\n    if (REG_CURRENT_COLOR.test(colorA)) {\n      rgbA = reInsertMissingColorComponents(CC_RGB, rgbA);\n    } else if (regMissingColor.test(colorA)) {\n      rgbA = reInsertMissingColorComponents(colorA, rgbA);\n    }\n    if (REG_CURRENT_COLOR.test(colorB)) {\n      rgbB = reInsertMissingColorComponents(CC_RGB, rgbB);\n    } else if (regMissingColor.test(colorB)) {\n      rgbB = reInsertMissingColorComponents(colorB, rgbB);\n    }\n    const [\n      [rA, gA, bA, aA],\n      [rB, gB, bB, aB]\n    ] = normalizeColorComponents(rgbA, rgbB);\n    const factorA = aA * pA;\n    const factorB = aB * pB;\n    a = (factorA + factorB);\n    if (a === 0) {\n      r = (rA * pA + rB * pB) * MAX_RGB;\n      g = (gA * pA + gB * pB) * MAX_RGB;\n      b = (bA * pA + bB * pB) * MAX_RGB;\n    } else {\n      r = (rA * factorA + rB * factorB) * a * MAX_RGB;\n      g = (gA * factorA + gB * factorB) * a * MAX_RGB;\n      b = (bA * factorA + bB * factorB) * a * MAX_RGB;\n    }\n  // in xyz, xyz-d65\n  } else if (/^xyz(?:-d65)?$/.test(colorSpace)) {\n    let xyzA, xyzB;\n    if (colorA.startsWith('color(')) {\n      xyzA = parseColorFunc(colorA);\n    } else {\n      xyzA = parseColorValue(colorA);\n    }\n    if (colorB.startsWith('color(')) {\n      xyzB = parseColorFunc(colorB);\n    } else {\n      xyzB = parseColorValue(colorB);\n    }\n    if (REG_CURRENT_COLOR.test(colorA)) {\n      xyzA = reInsertMissingColorComponents(CC_RGB, xyzA);\n    } else if (regMissingColor.test(colorA)) {\n      xyzA = reInsertMissingColorComponents(colorA, xyzA);\n    }\n    if (REG_CURRENT_COLOR.test(colorB)) {\n      xyzB = reInsertMissingColorComponents(CC_RGB, xyzB);\n    } else if (regMissingColor.test(colorB)) {\n      xyzB = reInsertMissingColorComponents(colorB, xyzB);\n    }\n    const [\n      [xA, yA, zA, aA],\n      [xB, yB, zB, aB]\n    ] = normalizeColorComponents(xyzA, xyzB);\n    const factorA = aA * pA;\n    const factorB = aB * pB;\n    a = (factorA + factorB);\n    let x, y, z;\n    if (a === 0) {\n      x = xA * pA + xB * pB;\n      y = yA * pA + yB * pB;\n      z = zA * pA + zB * pB;\n    } else {\n      x = (xA * factorA + xB * factorB) * a;\n      y = (yA * factorA + yB * factorB) * a;\n      z = (zA * factorA + zB * factorB) * a;\n    }\n    [r, g, b] = convertXyzToRgb([x, y, z]);\n  // in xyz-d50\n  } else if (colorSpace === 'xyz-d50') {\n    let xyzA, xyzB;\n    if (colorA.startsWith('color(')) {\n      xyzA = parseColorFunc(colorA, true);\n    } else {\n      xyzA = parseColorValue(colorA, true);\n    }\n    if (colorB.startsWith('color(')) {\n      xyzB = parseColorFunc(colorB, true);\n    } else {\n      xyzB = parseColorValue(colorB, true);\n    }\n    if (REG_CURRENT_COLOR.test(colorA)) {\n      xyzA = reInsertMissingColorComponents(CC_RGB, xyzA);\n    } else if (regMissingColor.test(colorA)) {\n      xyzA = reInsertMissingColorComponents(colorA, xyzA);\n    }\n    if (REG_CURRENT_COLOR.test(colorB)) {\n      xyzB = reInsertMissingColorComponents(CC_RGB, xyzB);\n    } else if (regMissingColor.test(colorB)) {\n      xyzB = reInsertMissingColorComponents(colorB, xyzB);\n    }\n    const [\n      [xA, yA, zA, aA],\n      [xB, yB, zB, aB]\n    ] = normalizeColorComponents(xyzA, xyzB);\n    const factorA = aA * pA;\n    const factorB = aB * pB;\n    a = (factorA + factorB);\n    let x, y, z;\n    if (a === 0) {\n      x = xA * pA + xB * pB;\n      y = yA * pA + yB * pB;\n      z = zA * pA + zB * pB;\n    } else {\n      x = (xA * factorA + xB * factorB) * a;\n      y = (yA * factorA + yB * factorB) * a;\n      z = (zA * factorA + zB * factorB) * a;\n    }\n    [r, g, b] = convertXyzD50ToRgb([x, y, z, a]);\n  // in hsl\n  } else if (colorSpace === 'hsl') {\n    let hA, sA, lA, aA;\n    if (colorA.startsWith('color(')) {\n      const xyz = parseColorFunc(colorA);\n      [hA, sA, lA, aA] = convertXyzToHsl(xyz);\n    } else {\n      const xyz = parseColorValue(colorA);\n      [hA, sA, lA, aA] = convertXyzToHsl(xyz);\n    }\n    let hB, sB, lB, aB;\n    if (colorB.startsWith('color(')) {\n      const xyz = parseColorFunc(colorB);\n      [hB, sB, lB, aB] = convertXyzToHsl(xyz);\n    } else {\n      const xyz = parseColorValue(colorB);\n      [hB, sB, lB, aB] = convertXyzToHsl(xyz);\n    }\n    if (REG_CURRENT_COLOR.test(colorA)) {\n      [lA, sA, hA, aA] =\n        reInsertMissingColorComponents(CC_LCH, [lA, sA, hA, aA]);\n    } else if (regMissingColor.test(colorA)) {\n      [lA, sA, hA, aA] =\n        reInsertMissingColorComponents(colorA, [lA, sA, hA, aA]);\n    }\n    if (REG_CURRENT_COLOR.test(colorB)) {\n      [lB, sB, hB, aB] =\n        reInsertMissingColorComponents(CC_LCH, [lB, sB, hB, aB]);\n    } else if (regMissingColor.test(colorB)) {\n      [lB, sB, hB, aB] =\n        reInsertMissingColorComponents(colorB, [lB, sB, hB, aB]);\n    }\n    [\n      [hA, sA, lA, aA],\n      [hB, sB, lB, aB]\n    ] = normalizeColorComponents([hA, sA, lA, aA], [hB, sB, lB, aB]);\n    const factorA = aA * pA;\n    const factorB = aB * pB;\n    a = (factorA + factorB);\n    const h = (hA * pA + hB * pB) % DEG;\n    let s, l;\n    if (a === 0) {\n      s = sA * pA + sB * pB;\n      l = lA * pA + lB * pB;\n    } else {\n      s = (sA * factorA + sB * factorB) / a;\n      l = (lA * factorA + lB * factorB) / a;\n    }\n    [r, g, b] = convertColorValueToRgb(`hsl(${h} ${s}% ${l}%)`);\n  // in hwb\n  } else if (colorSpace === 'hwb') {\n    let hA, wA, bA, aA;\n    if (colorA.startsWith('color(')) {\n      const xyz = parseColorFunc(colorA);\n      [hA, wA, bA, aA] = convertXyzToHwb(xyz);\n    } else {\n      const xyz = parseColorValue(colorA);\n      [hA, wA, bA, aA] = convertXyzToHwb(xyz);\n    }\n    let hB, wB, bB, aB;\n    if (colorB.startsWith('color(')) {\n      const xyz = parseColorFunc(colorB);\n      [hB, wB, bB, aB] = convertXyzToHwb(xyz);\n    } else {\n      const xyz = parseColorValue(colorB);\n      [hB, wB, bB, aB] = convertXyzToHwb(xyz);\n    }\n    if (REG_CURRENT_COLOR.test(colorA)) {\n      [,, hA, aA] =\n        reInsertMissingColorComponents(CC_LCH, [null, null, hA, aA]);\n    } else if (regMissingColor.test(colorA)) {\n      [,, hA, aA] =\n        reInsertMissingColorComponents(colorA, [null, null, hA, aA]);\n    }\n    if (REG_CURRENT_COLOR.test(colorB)) {\n      [,, hB, aB] =\n        reInsertMissingColorComponents(CC_LCH, [null, null, hB, aB]);\n    } else if (regMissingColor.test(colorB)) {\n      [,, hB, aB] =\n        reInsertMissingColorComponents(colorB, [null, null, hB, aB]);\n    }\n    [\n      [hA, wA, bA, aA],\n      [hB, wB, bB, aB]\n    ] = normalizeColorComponents([hA, wA, bA, aA], [hB, wB, bB, aB]);\n    const factorA = aA * pA;\n    const factorB = aB * pB;\n    a = (factorA + factorB);\n    const h = (hA * pA + hB * pB) % DEG;\n    let w, bk;\n    if (a === 0) {\n      w = wA * pA + wB * pB;\n      bk = bA * pA + bB * pB;\n    } else {\n      w = (wA * factorA + wB * factorB) / a;\n      bk = (bA * factorA + bB * factorB) / a;\n    }\n    const rgb = convertColorValueToRgb(`hwb(${h} ${w}% ${bk}%)`);\n    [r, g, b] = rgb;\n  // in lab\n  } else if (colorSpace === 'lab') {\n    let lA, aA, bA, aaA;\n    if (colorA.startsWith('color(')) {\n      const xyz = parseColorFunc(colorA, true);\n      [lA, aA, bA, aaA] = convertXyzD50ToLab(xyz);\n    } else {\n      const xyz = parseColorValue(colorA, true);\n      [lA, aA, bA, aaA] = convertXyzD50ToLab(xyz);\n    }\n    let lB, aB, bB, aaB;\n    if (colorB.startsWith('color(')) {\n      const xyz = parseColorFunc(colorB, true);\n      [lB, aB, bB, aaB] = convertXyzD50ToLab(xyz);\n    } else {\n      const xyz = parseColorValue(colorB, true);\n      [lB, aB, bB, aaB] = convertXyzD50ToLab(xyz);\n    }\n    if (REG_CURRENT_COLOR.test(colorA)) {\n      [lA,,, aaA] =\n        reInsertMissingColorComponents(CC_LCH, [lA, null, null, aaA]);\n    } else if (regMissingColor.test(colorA)) {\n      [lA,,, aaA] =\n        reInsertMissingColorComponents(colorA, [lA, null, null, aaA]);\n    }\n    if (REG_CURRENT_COLOR.test(colorB)) {\n      [lB,,, aaB] =\n        reInsertMissingColorComponents(CC_LCH, [lB, null, null, aaB]);\n    } else if (regMissingColor.test(colorB)) {\n      [lB,,, aaB] =\n        reInsertMissingColorComponents(colorB, [lB, null, null, aaB]);\n    }\n    [\n      [lA, aA, bA, aaA],\n      [lB, aB, bB, aaB]\n    ] = normalizeColorComponents([lA, aA, bA, aaA], [lB, aB, bB, aaB]);\n    const factorA = aaA * pA;\n    const factorB = aaB * pB;\n    a = (factorA + factorB);\n    let l, aX, bY;\n    if (a === 0) {\n      l = lA * pA + lB * pB;\n      aX = aA * pA + aB * pB;\n      bY = bA * pA + bB * pB;\n    } else {\n      l = (lA * factorA + lB * factorB) * a;\n      aX = (aA * factorA + aB * factorB) * a;\n      bY = (bA * factorA + bB * factorB) * a;\n    }\n    [r, g, b] = resolveColorValue(`lab(${l} ${aX} ${bY})`);\n  // in lch\n  } else if (colorSpace === 'lch') {\n    let lchA, lchB;\n    if (colorA.startsWith('color(')) {\n      const xyz = parseColorFunc(colorA, true);\n      lchA = convertXyzD50ToLch(xyz);\n    } else {\n      const xyz = parseColorValue(colorA, true);\n      lchA = convertXyzD50ToLch(xyz);\n    }\n    if (colorB.startsWith('color(')) {\n      const xyz = parseColorFunc(colorB, true);\n      lchB = convertXyzD50ToLch(xyz);\n    } else {\n      const xyz = parseColorValue(colorB, true);\n      lchB = convertXyzD50ToLch(xyz);\n    }\n    if (REG_CURRENT_COLOR.test(colorA)) {\n      lchA = reInsertMissingColorComponents(CC_LCH, lchA);\n    } else if (regMissingColor.test(colorA)) {\n      lchA = reInsertMissingColorComponents(colorA, lchA);\n    }\n    if (REG_CURRENT_COLOR.test(colorB)) {\n      lchB = reInsertMissingColorComponents(CC_LCH, lchB);\n    } else if (regMissingColor.test(colorB)) {\n      lchB = reInsertMissingColorComponents(colorB, lchB);\n    }\n    const [\n      [lA, cA, hA, aA],\n      [lB, cB, hB, aB]\n    ] = normalizeColorComponents(lchA, lchB);\n    const factorA = aA * pA;\n    const factorB = aB * pB;\n    a = (factorA + factorB);\n    let l, c, h;\n    if (a === 0) {\n      l = lA * pA + lB * pB;\n      c = cA * pA + cB * pB;\n      h = hA * pA + hB * pB;\n    } else {\n      l = (lA * factorA + lB * factorB) * a;\n      c = (cA * factorA + cB * factorB) * a;\n      h = (hA * factorA + hB * factorB) * a;\n    }\n    [r, g, b] = resolveColorValue(`lch(${l} ${c} ${h})`);\n  // in oklab\n  } else if (colorSpace === 'oklab') {\n    let lA, aA, bA, aaA;\n    if (colorA.startsWith('color(')) {\n      const xyz = parseColorFunc(colorA);\n      [lA, aA, bA, aaA] = convertXyzToOklab(xyz);\n    } else {\n      const xyz = parseColorValue(colorA);\n      [lA, aA, bA, aaA] = convertXyzToOklab(xyz);\n    }\n    let lB, aB, bB, aaB;\n    if (colorB.startsWith('color(')) {\n      const xyz = parseColorFunc(colorB);\n      [lB, aB, bB, aaB] = convertXyzToOklab(xyz);\n    } else {\n      const xyz = parseColorValue(colorB);\n      [lB, aB, bB, aaB] = convertXyzToOklab(xyz);\n    }\n    if (REG_CURRENT_COLOR.test(colorA)) {\n      [lA,,, aaA] =\n        reInsertMissingColorComponents(CC_LCH, [lA, null, null, aaA]);\n    } else if (regMissingColor.test(colorA)) {\n      [lA,,, aaA] =\n        reInsertMissingColorComponents(colorA, [lA, null, null, aaA]);\n    }\n    if (REG_CURRENT_COLOR.test(colorB)) {\n      [lA,,, aaB] =\n        reInsertMissingColorComponents(CC_LCH, [lB, null, null, aaB]);\n    } else if (regMissingColor.test(colorB)) {\n      [lB,,, aaB] =\n        reInsertMissingColorComponents(colorB, [lB, null, null, aaB]);\n    }\n    [\n      [lA, aA, bA, aaA],\n      [lB, aB, bB, aaB]\n    ] = normalizeColorComponents([lA, aA, bA, aaA], [lB, aB, bB, aaB]);\n    const factorA = aaA * pA;\n    const factorB = aaB * pB;\n    a = (factorA + factorB);\n    let l, aX, bY;\n    if (a === 0) {\n      l = lA * pA + lB * pB;\n      aX = aA * pA + aB * pB;\n      bY = bA * pA + bB * pB;\n    } else {\n      l = (lA * factorA + lB * factorB) * a;\n      aX = (aA * factorA + aB * factorB) * a;\n      bY = (bA * factorA + bB * factorB) * a;\n    }\n    [r, g, b] = resolveColorValue(`oklab(${l} ${aX} ${bY})`);\n  // in oklch\n  } else if (colorSpace === 'oklch') {\n    let lchA, lchB;\n    if (colorA.startsWith('color(')) {\n      const xyz = parseColorFunc(colorA, true);\n      lchA = convertXyzToOklch(xyz);\n    } else {\n      const xyz = parseColorValue(colorA, true);\n      lchA = convertXyzToOklch(xyz);\n    }\n    if (colorB.startsWith('color(')) {\n      const xyz = parseColorFunc(colorB, true);\n      lchB = convertXyzToOklch(xyz);\n    } else {\n      const xyz = parseColorValue(colorB, true);\n      lchB = convertXyzToOklch(xyz);\n    }\n    if (REG_CURRENT_COLOR.test(colorA)) {\n      lchA = reInsertMissingColorComponents(CC_LCH, lchA);\n    } else if (regMissingColor.test(colorA)) {\n      lchA = reInsertMissingColorComponents(colorA, lchA);\n    }\n    if (REG_CURRENT_COLOR.test(colorB)) {\n      lchB = reInsertMissingColorComponents(CC_LCH, lchB);\n    } else if (regMissingColor.test(colorB)) {\n      lchB = reInsertMissingColorComponents(colorB, lchB);\n    }\n    if (regMissingColor.test(colorA)) {\n      lchA = reInsertMissingColorComponents(colorA, lchA);\n    }\n    if (regMissingColor.test(colorB)) {\n      lchB = reInsertMissingColorComponents(colorB, lchB);\n    }\n    const [\n      [lA, cA, hA, aaA],\n      [lB, cB, hB, aaB]\n    ] = normalizeColorComponents(lchA, lchB);\n    const factorA = aaA * pA;\n    const factorB = aaB * pB;\n    a = (factorA + factorB);\n    let l, c, h;\n    if (a === 0) {\n      l = lA * pA + lB * pB;\n      c = cA * pA + cB * pB;\n      h = hA * pA + hB * pB;\n    } else {\n      l = (lA * factorA + lB * factorB) * a;\n      c = (cA * factorA + cB * factorB) * a;\n      h = (hA * factorA + hB * factorB) * a;\n    }\n    [r, g, b] = resolveColorValue(`oklch(${l} ${c} ${h})`);\n  }\n  return [r, g, b, a * m];\n};\n", "/**\n * convert.js\n */\n\nimport { LRUCache } from 'lru-cache';\nimport {\n  convertHexToRgb, convertRgbToHex, convertXyzD50ToHex, convertXyzD50ToLab,\n  convertXyzD50ToLch, convertXyzToHex, convertXyzToHsl, convertXyzToHwb,\n  convertXyzToOklab, convertXyzToOklch, convertXyzToRgb, convertXyzToXyzD50,\n  numberToHexString\n} from './color.js';\nimport { isString } from './common.js';\n\n/* cached results */\nexport const cachedResults = new LRUCache({\n  max: 4096\n});\n\n/**\n * convert hex color to rgb\n * @param {string} value - color value\n * @returns {Array.<number>} - [r, g, b, a] r|g|b: 0..255 a: 0..1\n */\nexport const hexToRgb = value => {\n  const cacheKey =\n    isString(value) && `{hexToRgb:${value.toLowerCase().trim()}}`;\n  if (cacheKey && cachedResults.has(cacheKey)) {\n    return cachedResults.get(cacheKey);\n  }\n  const res = convertHexToRgb(value);\n  if (cacheKey) {\n    cachedResults.set(cacheKey, res);\n  }\n  return res;\n};\n\n/**\n * convert number to hex string\n * @param {number} value - color value\n * @returns {string} - hex string\n */\nexport const numberToHex = value => {\n  const cacheKey = typeof value === 'number' && `{numberToHex:${value}}`;\n  if (cacheKey && cachedResults.has(cacheKey)) {\n    return cachedResults.get(cacheKey);\n  }\n  const res = numberToHexString(value);\n  if (cacheKey) {\n    cachedResults.set(cacheKey, res);\n  }\n  return res;\n};\n\n/**\n * convert rgb to hex color\n * @param {Array.<number>} rgb - [r, g, b, a] r|g|b: 0..255 a: 0..1\n * @returns {string} - hex color;\n */\nexport const rgbToHex = rgb => {\n  const cacheKey = `{name:rgbToHex,rgb:${JSON.stringify(rgb)}}`;\n  if (cachedResults.has(cacheKey)) {\n    return cachedResults.get(cacheKey);\n  }\n  const res = convertRgbToHex(rgb);\n  cachedResults.set(cacheKey, res);\n  return res;\n};\n\n/**\n * convert xyz\n * @param {Array.<number>} xyz - [x, y, z, a] x|y|z|a: 0..1\n * @param {string} name - function name\n * @returns {string|Array.<number>} - result\n */\nexport const convertXyz = (xyz, name) => {\n  const cacheKey = `{${name}:${JSON.stringify(xyz)}}`;\n  if (cachedResults.has(cacheKey)) {\n    return cachedResults.get(cacheKey);\n  }\n  let res;\n  switch (name) {\n    case 'xyzD50ToHex': {\n      res = convertXyzD50ToHex(xyz);\n      break;\n    }\n    case 'xyzD50ToLab': {\n      res = convertXyzD50ToLab(xyz);\n      break;\n    }\n    case 'xyzD50ToLch': {\n      res = convertXyzD50ToLch(xyz);\n      break;\n    }\n    case 'xyzToHex': {\n      res = convertXyzToHex(xyz);\n      break;\n    }\n    case 'xyzToHsl': {\n      res = convertXyzToHsl(xyz);\n      break;\n    }\n    case 'xyzToHwb': {\n      res = convertXyzToHwb(xyz);\n      break;\n    }\n    case 'xyzToOklab': {\n      res = convertXyzToOklab(xyz);\n      break;\n    }\n    case 'xyzToOklch': {\n      res = convertXyzToOklch(xyz);\n      break;\n    }\n    case 'xyzToRgb': {\n      res = convertXyzToRgb(xyz);\n      break;\n    }\n    case 'xyzToXyzD50': {\n      res = convertXyzToXyzD50(xyz);\n      break;\n    }\n    default: {\n      throw new Error(`Invalid converter name: ${name}`);\n    }\n  }\n  cachedResults.set(cacheKey, res);\n  return res;\n};\n\n/**\n * convert xyz D50 to hex color\n * @param {Array.<number>} xyz - [x, y, z, a] x|y|z|a: 0..1\n * @returns {string} - hex color\n */\nexport const xyzD50ToHex = xyz => convertXyz(xyz, 'xyzD50ToHex');\n\n/**\n * convert xyz-d50 to lab\n * @param {Array.<number>} xyz - [x, y, z, a] x|y|z|a: 0..1\n * @returns {Array.<number>} - [l, a, b, aa] l: 0..100 a|b: -125..125 aa: 0..1\n */\nexport const xyzD50ToLab = xyz => convertXyz(xyz, 'xyzD50ToLab');\n\n/**\n * convert xyz-d50 to lch\n * @param {Array.<number>} xyz - [x, y, z, a] x|y|z|a: 0..1\n * @returns {Array.<number>} - [l, c, h, a] l: 0..100 c: 0..150 h: 0..360 a: 0..1\n */\nexport const xyzD50ToLch = xyz => convertXyz(xyz, 'xyzD50ToLch');\n\n/**\n * convert xyz to hex color\n * @param {Array.<number>} xyz - [x, y, z, a] x|y|z|a: 0..1\n * @returns {string} - hex color\n */\nexport const xyzToHex = xyz => convertXyz(xyz, 'xyzToHex');\n\n/**\n * convert xyz to hsl\n * @param {Array.<number>} xyz - [x, y, z, a] x|y|z|a: 0..1\n * @returns {Array.<number>} - [h, s, l, a] h: 0..360 s|l: 0..100 a: 0..1\n */\nexport const xyzToHsl = xyz => convertXyz(xyz, 'xyzToHsl');\n\n/**\n * convert xyz to hwb\n * @param {Array.<number>} xyz - [x, y, z, a] x|y|z|a: 0..1\n * @returns {Array.<number>} - [h, w, b, a] h: 0..360 w|b: 0..100 a: 0..1\n */\nexport const xyzToHwb = xyz => convertXyz(xyz, 'xyzToHwb');\n\n/**\n * convert xyz to oklab\n * @param {Array.<number>} xyz - [x, y, z, a] x|y|z|a: 0..1\n * @returns {Array.<number>} - [l, a, b, aa] l|aa: 0..1 a|b: -0.4..0.4\n */\nexport const xyzToOklab = xyz => convertXyz(xyz, 'xyzToOklab');\n\n/**\n * convert xyz to oklch\n * @param {Array.<number>} xyz - [x, y, z, a] x|y|z|a: 0..1\n * @returns {Array.<number>} - [l, c, h, aa] l|aa: 0..1 c: 0..0.4 h: 0..360\n */\nexport const xyzToOklch = xyz => convertXyz(xyz, 'xyzToOklch');\n\n/**\n * convert xyz to rgb\n * @param {Array.<number>} xyz - [x, y, z, a] x|y|z|a: 0..1\n * @returns {Array.<number>} - [r, g, b, a] r|g|b: 0..255 a: 0..1\n */\nexport const xyzToRgb = xyz => convertXyz(xyz, 'xyzToRgb');\n\n/**\n * convert xyz to xyz-d50\n * @param {Array.<number>} xyz - [x, y, z, a] x|y|z|a: 0..1\n * @returns {Array.<number>} xyz - [x, y, z, a] x|y|z|a: 0..1\n */\nexport const xyzToXyzD50 = xyz => convertXyz(xyz, 'xyzToXyzD50');\n\n/* wrap converters */\nexport const convert = {\n  hexToRgb,\n  numberToHex,\n  rgbToHex,\n  xyzD50ToHex,\n  xyzD50ToLab,\n  xyzD50ToLch,\n  xyzToHex,\n  xyzToHsl,\n  xyzToHwb,\n  xyzToOklab,\n  xyzToOklch,\n  xyzToRgb,\n  xyzToXyzD50\n};\n", "/**\n * api.js\n */\n\nimport { LRUCache } from 'lru-cache';\nimport {\n  convertRgbToHex, parseColorFunc, parseColorValue, resolveColorFunc,\n  resolveColorMix, resolveColorValue\n} from './color.js';\nimport { getType, isString } from './common.js';\nexport { convert } from './convert.js';\n\n/* cached results */\nexport const cachedResults = new LRUCache({\n  max: 4096\n});\n\n/**\n * resolve CSS color\n * @param {string} color - color value\n *   - system colors are not supported\n * @param {object} [opt] - options\n * @param {string} [opt.currentColor] - color to use for `currentcolor` keyword\n * @param {string} [opt.format] - `rgb`(default), `array`, `hex` or `hexAlpha`\n *   - `hexAlpha` is a hex color notation with alpha channel, i.e. #rrggbbaa\n * @param {*} [opt.key] - key e.g. CSS property `background-color`\n * @returns {?string|Array} - rgba?(), [r, g, b, a], #rrggbb(aa)?, null\n *   - if `key` is specified, [key, rgba?()|[r, g, b, a]|#rrggbb(aa)?|null]\n *   - in `rgb`, `r`, `g`, `b` values are rounded,\n *     resolves as empty string if any of `r`, `g`, `b`, `a` is not a number\n *   - in `array`, values are floating point,\n *     if any of `r`, `g`, `b`, `a` is not a number then they stay as is,\n *     e.g. [undefined, undefined, undefined, undefined]\n *   - in `hex`, `transparent` resolves as `null`,\n *     also resolves as `null` if any of `r`, `g`, `b`, `a` is not a number\n *   - in `hexAlpha`, resolves as `null` if any of `r`, `g`, `b`, `a` is not a number\n */\nexport const resolve = (color, opt = {}) => {\n  if (isString(color)) {\n    color = color.trim();\n  } else {\n    throw new TypeError(`Expected String but got ${getType(color)}.`);\n  }\n  const cacheKey =\n    `{resolve:${color.toLowerCase()},opt:${JSON.stringify(opt)}}`;\n  if (cachedResults.has(cacheKey)) {\n    return cachedResults.get(cacheKey);\n  }\n  const { currentColor, format, key } = opt;\n  let r, g, b, a;\n  if (/^currentcolor$/i.test(color)) {\n    if (currentColor) {\n      if (currentColor.startsWith('color-mix')) {\n        [r, g, b, a] = resolveColorMix(currentColor);\n      } else if (currentColor.startsWith('color(')) {\n        [r, g, b, a] = resolveColorFunc(currentColor);\n      } else {\n        [r, g, b, a] = resolveColorValue(currentColor);\n      }\n    } else {\n      r = 0;\n      g = 0;\n      b = 0;\n      a = 0;\n    }\n  } else if (/currentcolor/i.test(color)) {\n    if (/transparent/i.test(color)) {\n      color = color.replace(/transparent/gi, 'rgba(0, 0, 0, 0)');\n    }\n    if (currentColor && color.startsWith('color-mix')) {\n      color = color.replace(/currentcolor/gi, currentColor);\n      [r, g, b, a] = resolveColorMix(color);\n    }\n  } else if (/^transparent$/i.test(color)) {\n    r = 0;\n    g = 0;\n    b = 0;\n    a = 0;\n  } else if (/transparent/i.test(color)) {\n    color = color.replace(/transparent/gi, 'rgba(0, 0, 0, 0)');\n    if (color.startsWith('color-mix')) {\n      [r, g, b, a] = resolveColorMix(color);\n    }\n  } else if (color.startsWith('color-mix')) {\n    [r, g, b, a] = resolveColorMix(color);\n  } else if (color.startsWith('color(')) {\n    [r, g, b, a] = resolveColorFunc(color);\n  } else {\n    [r, g, b, a] = resolveColorValue(color);\n  }\n  let res;\n  switch (format) {\n    case 'array': {\n      if (key) {\n        res = [key, [r, g, b, a]];\n      } else {\n        res = [r, g, b, a];\n      }\n      break;\n    }\n    case 'hex': {\n      let hex;\n      if (/^transparent$/i.test(color) || isNaN(r) || isNaN(g) || isNaN(b)) {\n        hex = null;\n      } else {\n        hex = convertRgbToHex([r, g, b]);\n      }\n      if (key) {\n        res = [key, hex];\n      } else {\n        res = hex;\n      }\n      break;\n    }\n    case 'hexAlpha': {\n      let hex;\n      if (/^transparent$/i.test(color)) {\n        hex = '#00000000';\n      } else if (isNaN(r) || isNaN(g) || isNaN(b) || isNaN(a)) {\n        hex = null;\n      } else {\n        hex = convertRgbToHex([r, g, b, a]);\n      }\n      if (key) {\n        res = [key, hex];\n      } else {\n        res = hex;\n      }\n      break;\n    }\n    default: {\n      let rgb;\n      if (isNaN(r) || isNaN(g) || isNaN(b) || isNaN(a)) {\n        rgb = '';\n      } else {\n        r = Math.round(r);\n        g = Math.round(g);\n        b = Math.round(b);\n        if (a === 1) {\n          rgb = `rgb(${r}, ${g}, ${b})`;\n        } else {\n          rgb = `rgba(${r}, ${g}, ${b}, ${a})`;\n        }\n      }\n      if (key) {\n        res = [key, rgb];\n      } else {\n        res = rgb;\n      }\n    }\n  }\n  cachedResults.set(cacheKey, res);\n  return res;\n};\n\n/**\n * parse CSS color\n * @param {string} value - color value\n *  - color-mix() and system colors are not supported\n * @param {object} [opt] - options\n * @param {boolean} [opt.d50] - xyz in d50 white point\n * @returns {Array.<number>} - [x, y, z, a] x|y|z: around 0..1 a: 0..1\n */\nexport const parse = (value, opt = {}) => {\n  if (isString(value)) {\n    value = value.trim();\n    if (value.startsWith('color-mix(')) {\n      throw new Error('color-mix() is not supported.');\n    }\n  } else {\n    throw new TypeError(`Expected String but got ${getType(value)}.`);\n  }\n  const cacheKey = `{parse:${value.toLowerCase()},opt:${JSON.stringify(opt)}}`;\n  if (cachedResults.has(cacheKey)) {\n    return cachedResults.get(cacheKey);\n  }\n  const { d50 } = opt;\n  let xyz;\n  if (value.startsWith('color(')) {\n    xyz = parseColorFunc(value, d50);\n  } else {\n    xyz = parseColorValue(value, d50);\n  }\n  cachedResults.set(cacheKey, xyz);\n  return xyz;\n};\n"],
  "mappings": "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",
  "names": ["perf", "warned", "PROCESS", "emitWarning", "msg", "type", "code", "fn", "AC", "AS", "_", "warnACPolyfill", "reason", "printACPolyfillWarning", "shouldWarn", "TYPE", "isPosInt", "n", "getUintArray", "max", "ZeroArray", "size", "Stack", "_Stack", "#constructing", "HeapCls", "s", "LRUCache", "_LRUCache", "#max", "#maxSize", "#dispose", "#disposeAfter", "#fetchMethod", "#memoMethod", "#size", "#calculatedSize", "#keyMap", "#keyList", "#valList", "#next", "#prev", "#head", "#tail", "#free", "#disposed", "#sizes", "#starts", "#ttls", "#hasDispose", "#hasFetchMethod", "#hasDisposeAfter", "c", "p", "#isBackgroundFetch", "k", "index", "options", "context", "#backgroundFetch", "#moveToTail", "#indexes", "#rindexes", "#isStale", "ttl", "ttlResolution", "ttlAutopurge", "updateAgeOnGet", "updateAgeOnHas", "allowStale", "dispose", "disposeAfter", "noDisposeOnSet", "noUpdateTTL", "maxSize", "maxEntrySize", "sizeCalculation", "fetchMethod", "memoMethod", "noDeleteOnFetchRejection", "noDeleteOnStaleGet", "allowStaleOnFetchRejection", "allowStaleOnFetchAbort", "ignoreFetchAbort", "UintArray", "#initializeSizeTracking", "#initializeTTLTracking", "key", "ttls", "starts", "#setItemTTL", "start", "t", "#delete", "#updateItemAge", "#statusTTL", "status", "cachedNow", "getNow", "age", "sizes", "#removeItemSize", "#requireSize", "v", "#addItemSize", "#evict", "_i", "_s", "_st", "_k", "_v", "#isValidIndex", "i", "getOptions", "value", "thisp", "deleted", "entry", "remain", "arr", "setOptions", "oldVal", "oldValue", "dt", "task", "val", "free", "head", "hasOptions", "peekOptions", "ac", "signal", "fetchOpts", "cb", "updateCache", "aborted", "ignoreAbort", "fetchFail", "bf", "eb", "er", "allowStaleAborted", "noDelete", "pcall", "res", "rej", "fmp", "b", "fetchOptions", "forceRefresh", "stale", "isStale", "staleVal", "memoOptions", "vv", "fetching", "#connect", "#clear", "pi", "ni", "getType", "o", "isString", "HALF", "DUO", "TRIA", "QUAT", "DEC", "HEX", "DEG", "DEG_INTERVAL", "MAX_PCT", "MAX_RGB", "POW_SQUARE", "POW_CUBE", "POW_LINEAR", "LINEAR_COEF", "LINEAR_OFFSET", "LAB_L", "LAB_A", "LAB_B", "LAB_EPSILON", "LAB_KAPPA", "D50", "MATRIX_D50_TO_D65", "MATRIX_D65_TO_D50", "MATRIX_RGB_TO_XYZ", "MATRIX_XYZ_TO_RGB", "MATRIX_XYZ_TO_LMS", "MATRIX_LMS_TO_XYZ", "MATRIX_OKLAB_TO_LMS", "MATRIX_LMS_TO_OKLAB", "MATRIX_P3_TO_XYZ", "MATRIX_REC2020_TO_XYZ", "MATRIX_A98_TO_XYZ", "MATRIX_PROPHOTO_TO_XYZ_D50", "NONE", "REG_ANGLE", "REG_SRGB", "REG_COLOR_SPACE_XYZ", "REG_COLOR_SPACE_COLOR_MIX", "REG_COLOR_SPACE_RGB", "REG_NUM", "REG_PCT", "REG_HSL", "REG_HSL_LV3", "REG_RGB", "REG_RGB_LV3", "REG_LAB", "REG_LCH", "REG_COLOR_FUNC", "REG_COLOR_TYPE", "REG_COLOR_MIX_PART", "REG_COLOR_MIX_CAPT", "REG_CURRENT_COLOR", "NAMED_COLORS", "validateColorComponents", "arr", "opt", "getType", "alpha", "minLength", "maxLength", "minRange", "maxRange", "validateRange", "l", "msg", "i", "v", "transformMatrix", "mtx", "vct", "r1c1", "r1c2", "r1c3", "r2c1", "r2c2", "r2c3", "r3c1", "r3c2", "r3c3", "v1", "v2", "v3", "p1", "p2", "p3", "reInsertMissingColorComponents", "value", "color", "isString", "v4", "v1m", "v2m", "v3m", "v4m", "regRgb", "regColor", "regHsl", "regLab", "regLch", "normalizeColorComponents", "colorA", "colorB", "numberToHexString", "hex", "angleToDeg", "angle", "GRAD", "RAD", "reg", "val", "unit", "deg", "convertRgbToLinearRgb", "rgb", "rr", "gg", "bb", "r", "g", "b", "COND_POW", "convertRgbToXyz", "a", "x", "y", "z", "convertRgbToHex", "rgb", "r", "g", "b", "a", "validateColorComponents", "MAX_RGB", "rr", "numberToHexString", "gg", "bb", "aa", "hex", "convertLinearRgbToRgb", "TRIA", "COND_POW", "POW_LINEAR", "LINEAR_OFFSET", "LINEAR_COEF", "convertLinearRgbToHex", "QUAT", "convertXyzToHex", "xyz", "x", "y", "z", "transformMatrix", "MATRIX_XYZ_TO_RGB", "convertXyzD50ToHex", "xyzD65", "MATRIX_D50_TO_D65", "convertXyzToRgb", "convertXyzToXyzD50", "xx", "yy", "zz", "MATRIX_D65_TO_D50", "convertXyzToHsl", "max", "min", "d", "l", "HALF", "MAX_PCT", "h", "s", "NONE", "DUO", "DEG_INTERVAL", "DEG", "convertXyzToHwb", "w", "bk", "convertXyzToOklab", "xyzLms", "MATRIX_XYZ_TO_LMS", "c", "MATRIX_LMS_TO_OKLAB", "lPct", "convertXyzToOklch", "POW_SQUARE", "convertXyzD50ToRgb", "convertXyzD50ToLab", "xyzD50", "val", "i", "D50", "f0", "f1", "f2", "LAB_EPSILON", "LAB_KAPPA", "HEX", "LAB_L", "LAB_A", "LAB_B", "convertXyzD50ToLch", "convertHexToRgb", "value", "isString", "getType", "arr", "convertHexToLinearRgb", "convertRgbToLinearRgb", "convertHexToXyz", "MATRIX_RGB_TO_XYZ", "parseAlpha", "parseRgb", "reg", "REG_RGB", "REG_RGB_LV3", "parseHsl", "REG_HSL", "REG_HSL_LV3", "angleToDeg", "factor", "parseHwb", "v", "parseLab", "REG_LAB", "COEF_PCT", "fl", "fa", "fb", "powFl", "POW_CUBE", "powFa", "powFb", "parseLch", "REG_LCH", "parseOklab", "MATRIX_OKLAB_TO_LMS", "MATRIX_LMS_TO_XYZ", "parseOklch", "cl", "parseColorFunc", "d50", "REG_COLOR_FUNC", "cs", "v1", "v2", "v3", "v4", "convertRgbToXyz", "linearRgb", "MATRIX_P3_TO_XYZ", "ALPHA", "BETA", "REC_COEF", "DEC", "MATRIX_REC2020_TO_XYZ", "POW_A98", "MATRIX_A98_TO_XYZ", "MATRIX_PROPHOTO_TO_XYZ_D50", "parseColorValue", "REG_CURRENT_COLOR", "NAMED_COLORS", "convertColorValueToLinearRgb", "opt", "alpha", "convertColorValueToRgb", "resolveColorValue", "res", "resolveColorFunc", "resolveColorMix", "regColorMix", "REG_COLOR_MIX_CAPT", "CC_LCH", "CC_RGB", "regColorPart", "REG_COLOR_TYPE", "REG_PCT", "regMissingColor", "colorSpace", "colorPartA", "colorPartB", "colorA", "pctA", "colorB", "pctB", "pA", "pB", "m", "p1", "p2", "rgbA", "rgbB", "reInsertMissingColorComponents", "rA", "gA", "bA", "aA", "rB", "gB", "bB", "aB", "normalizeColorComponents", "factorA", "factorB", "xyzA", "xyzB", "xA", "yA", "zA", "xB", "yB", "zB", "hA", "sA", "lA", "hB", "sB", "lB", "wA", "wB", "aaA", "aaB", "aX", "bY", "lchA", "lchB", "cA", "cB", "cachedResults", "LRUCache", "hexToRgb", "value", "cacheKey", "isString", "res", "convertHexToRgb", "numberToHex", "numberToHexString", "rgbToHex", "rgb", "convertRgbToHex", "convertXyz", "xyz", "name", "convertXyzD50ToHex", "convertXyzD50ToLab", "convertXyzD50ToLch", "convertXyzToHex", "convertXyzToHsl", "convertXyzToHwb", "convertXyzToOklab", "convertXyzToOklch", "convertXyzToRgb", "convertXyzToXyzD50", "xyzD50ToHex", "xyzD50ToLab", "xyzD50ToLch", "xyzToHex", "xyzToHsl", "xyzToHwb", "xyzToOklab", "xyzToOklch", "xyzToRgb", "xyzToXyzD50", "convert", "cachedResults", "LRUCache", "resolve", "color", "opt", "isString", "getType", "cacheKey", "currentColor", "format", "key", "r", "g", "b", "a", "resolveColorMix", "resolveColorFunc", "resolveColorValue", "res", "hex", "convertRgbToHex", "rgb", "parse", "value", "d50", "xyz", "parseColorFunc", "parseColorValue"]
}
